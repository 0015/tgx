<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TGX: tgx::Renderer3D&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">TGX<span id="projectnumber">&#160;0.8</span>
   </div>
   <div id="projectbrief">Tiny Graphics Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classtgx_1_1_renderer3_d.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classtgx_1_1_renderer3_d-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">tgx::Renderer3D&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Class that manages a scene and draws 3D objects onto a <code><a class="el" href="classtgx_1_1_image.html">Image</a></code>.  
 <a href="classtgx_1_1_renderer3_d.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_renderer3_d_8h_source.html">Renderer3D.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a333d6126e522ba550b7ec8add6c600ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a333d6126e522ba550b7ec8add6c600ad">Renderer3D</a> (const <a class="el" href="_vec2_8h.html#a37eab41759a1a4093ac2fbde648b4c0f">iVec2</a> &amp;viewportSize={0, 0}, <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *im=nullptr, ZBUFFER_t *zbuffer=nullptr)</td></tr>
<tr class="memdesc:a333d6126e522ba550b7ec8add6c600ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classtgx_1_1_renderer3_d.html#a333d6126e522ba550b7ec8add6c600ad">More...</a><br /></td></tr>
<tr class="separator:a333d6126e522ba550b7ec8add6c600ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7222e72a480ce99a8eb3d3df2dfec0aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a7222e72a480ce99a8eb3d3df2dfec0aa">setViewportSize</a> (int lx, int ly)</td></tr>
<tr class="memdesc:a7222e72a480ce99a8eb3d3df2dfec0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the size of the viewport.  <a href="classtgx_1_1_renderer3_d.html#a7222e72a480ce99a8eb3d3df2dfec0aa">More...</a><br /></td></tr>
<tr class="separator:a7222e72a480ce99a8eb3d3df2dfec0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1030e0892d613c3406811755bda599"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a6f1030e0892d613c3406811755bda599">setViewportSize</a> (const <a class="el" href="_vec2_8h.html#a37eab41759a1a4093ac2fbde648b4c0f">iVec2</a> &amp;viewport_dim)</td></tr>
<tr class="memdesc:a6f1030e0892d613c3406811755bda599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the size of the viewport.  <a href="classtgx_1_1_renderer3_d.html#a6f1030e0892d613c3406811755bda599">More...</a><br /></td></tr>
<tr class="separator:a6f1030e0892d613c3406811755bda599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e31001994fa3444b15e7037a1d5f1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a99e31001994fa3444b15e7037a1d5f1d">setImage</a> (<a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *im)</td></tr>
<tr class="memdesc:a99e31001994fa3444b15e7037a1d5f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the image that will be drawn onto.  <a href="classtgx_1_1_renderer3_d.html#a99e31001994fa3444b15e7037a1d5f1d">More...</a><br /></td></tr>
<tr class="separator:a99e31001994fa3444b15e7037a1d5f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1eaf179bc6573ab508ab3a7e38dab9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#afc1eaf179bc6573ab508ab3a7e38dab9">setOffset</a> (int ox, int oy)</td></tr>
<tr class="memdesc:afc1eaf179bc6573ab508ab3a7e38dab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the offset of the image relative to the viewport.  <a href="classtgx_1_1_renderer3_d.html#afc1eaf179bc6573ab508ab3a7e38dab9">More...</a><br /></td></tr>
<tr class="separator:afc1eaf179bc6573ab508ab3a7e38dab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4fa24bc6a4c5235df0ae3e112c48b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#aae4fa24bc6a4c5235df0ae3e112c48b3">setOffset</a> (const <a class="el" href="_vec2_8h.html#a37eab41759a1a4093ac2fbde648b4c0f">iVec2</a> &amp;offset)</td></tr>
<tr class="memdesc:aae4fa24bc6a4c5235df0ae3e112c48b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the offset of the image relative to the viewport.  <a href="classtgx_1_1_renderer3_d.html#aae4fa24bc6a4c5235df0ae3e112c48b3">More...</a><br /></td></tr>
<tr class="separator:aae4fa24bc6a4c5235df0ae3e112c48b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c31304f8ec4425401629a7846adff5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#af0c31304f8ec4425401629a7846adff5">setProjectionMatrix</a> (const <a class="el" href="_mat4_8h.html#aa543bb38f59d79a08113a6254b587322">fMat4</a> &amp;M)</td></tr>
<tr class="memdesc:af0c31304f8ec4425401629a7846adff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the projection matrix.  <a href="classtgx_1_1_renderer3_d.html#af0c31304f8ec4425401629a7846adff5">More...</a><br /></td></tr>
<tr class="separator:af0c31304f8ec4425401629a7846adff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bce4752b73a38862733b4f2bcb6f04f"><td class="memItemLeft" align="right" valign="top"><a id="a4bce4752b73a38862733b4f2bcb6f04f" name="a4bce4752b73a38862733b4f2bcb6f04f"></a>
<a class="el" href="_mat4_8h.html#aa543bb38f59d79a08113a6254b587322">fMat4</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getProjectionMatrix</b> () const</td></tr>
<tr class="memdesc:a4bce4752b73a38862733b4f2bcb6f04f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the current projection matrix. <br /></td></tr>
<tr class="separator:a4bce4752b73a38862733b4f2bcb6f04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7c15aa00b471522a50af525cf41032"><td class="memItemLeft" align="right" valign="top"><a id="acf7c15aa00b471522a50af525cf41032" name="acf7c15aa00b471522a50af525cf41032"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>useOrthographicProjection</b> ()</td></tr>
<tr class="memdesc:acf7c15aa00b471522a50af525cf41032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set projection mode to orthographic (ie no z-divide) <br /></td></tr>
<tr class="separator:acf7c15aa00b471522a50af525cf41032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bff46c6c71c78546267d7b75bb12644"><td class="memItemLeft" align="right" valign="top"><a id="a7bff46c6c71c78546267d7b75bb12644" name="a7bff46c6c71c78546267d7b75bb12644"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>usePerspectiveProjection</b> ()</td></tr>
<tr class="memdesc:a7bff46c6c71c78546267d7b75bb12644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set projection mode to perspective (ie with z-divide) <br /></td></tr>
<tr class="separator:a7bff46c6c71c78546267d7b75bb12644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff9976b53c527e62c95be427620685f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a8ff9976b53c527e62c95be427620685f">setOrtho</a> (float left, float right, float bottom, float top, float zNear, float zFar)</td></tr>
<tr class="memdesc:a8ff9976b53c527e62c95be427620685f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the projection matrix as an orthographic matrix: <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml</a>.  <a href="classtgx_1_1_renderer3_d.html#a8ff9976b53c527e62c95be427620685f">More...</a><br /></td></tr>
<tr class="separator:a8ff9976b53c527e62c95be427620685f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ae032c0be73580be8e61c53ad42545"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#af0ae032c0be73580be8e61c53ad42545">setFrustum</a> (float left, float right, float bottom, float top, float zNear, float zFar)</td></tr>
<tr class="memdesc:af0ae032c0be73580be8e61c53ad42545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the projection matrix as a perspective matrix <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFrustum.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFrustum.xml</a>.  <a href="classtgx_1_1_renderer3_d.html#af0ae032c0be73580be8e61c53ad42545">More...</a><br /></td></tr>
<tr class="separator:af0ae032c0be73580be8e61c53ad42545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8437622c6b90f9429769504848d22456"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a8437622c6b90f9429769504848d22456">setPerspective</a> (float fovy, float aspect, float zNear, float zFar)</td></tr>
<tr class="memdesc:a8437622c6b90f9429769504848d22456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the projection matrix as a perspective matrix <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml</a>.  <a href="classtgx_1_1_renderer3_d.html#a8437622c6b90f9429769504848d22456">More...</a><br /></td></tr>
<tr class="separator:a8437622c6b90f9429769504848d22456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fa32770476cd15f717d3f103fd752d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a76fa32770476cd15f717d3f103fd752d">setCulling</a> (int w)</td></tr>
<tr class="memdesc:a76fa32770476cd15f717d3f103fd752d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the face culling strategy.  <a href="classtgx_1_1_renderer3_d.html#a76fa32770476cd15f717d3f103fd752d">More...</a><br /></td></tr>
<tr class="separator:a76fa32770476cd15f717d3f103fd752d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516e700a5470f52cbd9a82dd59f8c968"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a516e700a5470f52cbd9a82dd59f8c968">setZbuffer</a> (ZBUFFER_t *zbuffer)</td></tr>
<tr class="memdesc:a516e700a5470f52cbd9a82dd59f8c968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the zbuffer.  <a href="classtgx_1_1_renderer3_d.html#a516e700a5470f52cbd9a82dd59f8c968">More...</a><br /></td></tr>
<tr class="separator:a516e700a5470f52cbd9a82dd59f8c968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad613bdffc57596703abe1a2a47583003"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#ad613bdffc57596703abe1a2a47583003">clearZbuffer</a> ()</td></tr>
<tr class="memdesc:ad613bdffc57596703abe1a2a47583003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the Zbuffer.  <a href="classtgx_1_1_renderer3_d.html#ad613bdffc57596703abe1a2a47583003">More...</a><br /></td></tr>
<tr class="separator:ad613bdffc57596703abe1a2a47583003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04191294450f9371c8c99e869075b40e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a04191294450f9371c8c99e869075b40e">setShaders</a> (int shaders)</td></tr>
<tr class="memdesc:a04191294450f9371c8c99e869075b40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the shaders to use for subsequent drawing operations.  <a href="classtgx_1_1_renderer3_d.html#a04191294450f9371c8c99e869075b40e">More...</a><br /></td></tr>
<tr class="separator:a04191294450f9371c8c99e869075b40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63f6218b3f5b451784eb32282102553"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#af63f6218b3f5b451784eb32282102553">setTextureWrappingMode</a> (int wrap_mode)</td></tr>
<tr class="memdesc:af63f6218b3f5b451784eb32282102553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the wrap mode when using texturing.  <a href="classtgx_1_1_renderer3_d.html#af63f6218b3f5b451784eb32282102553">More...</a><br /></td></tr>
<tr class="separator:af63f6218b3f5b451784eb32282102553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f24c4f139eccc4b9a695ca681970cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a78f24c4f139eccc4b9a695ca681970cc">setTextureQuality</a> (int quality)</td></tr>
<tr class="memdesc:a78f24c4f139eccc4b9a695ca681970cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the texturing quality.  <a href="classtgx_1_1_renderer3_d.html#a78f24c4f139eccc4b9a695ca681970cc">More...</a><br /></td></tr>
<tr class="separator:a78f24c4f139eccc4b9a695ca681970cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cad095ff0d7eefbdb93ac04b6a3efff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a6cad095ff0d7eefbdb93ac04b6a3efff">setViewMatrix</a> (const <a class="el" href="_mat4_8h.html#aa543bb38f59d79a08113a6254b587322">fMat4</a> &amp;M)</td></tr>
<tr class="memdesc:a6cad095ff0d7eefbdb93ac04b6a3efff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the view tranformation matrix.  <a href="classtgx_1_1_renderer3_d.html#a6cad095ff0d7eefbdb93ac04b6a3efff">More...</a><br /></td></tr>
<tr class="separator:a6cad095ff0d7eefbdb93ac04b6a3efff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bf226bb8236ad48314bca2bd0f31f8"><td class="memItemLeft" align="right" valign="top"><a id="a35bf226bb8236ad48314bca2bd0f31f8" name="a35bf226bb8236ad48314bca2bd0f31f8"></a>
<a class="el" href="_mat4_8h.html#aa543bb38f59d79a08113a6254b587322">fMat4</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getViewMatrix</b> () const</td></tr>
<tr class="memdesc:a35bf226bb8236ad48314bca2bd0f31f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the current view matrix. <br /></td></tr>
<tr class="separator:a35bf226bb8236ad48314bca2bd0f31f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6d8dbf64d64db311eb2854bdf1ceb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#abd6d8dbf64d64db311eb2854bdf1ceb1">setLookAt</a> (float eyeX, float eyeY, float eyeZ, float centerX, float centerY, float centerZ, float upX, float upY, float upZ)</td></tr>
<tr class="memdesc:abd6d8dbf64d64db311eb2854bdf1ceb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the view matrix so that the camera is looking at a given direction.  <a href="classtgx_1_1_renderer3_d.html#abd6d8dbf64d64db311eb2854bdf1ceb1">More...</a><br /></td></tr>
<tr class="separator:abd6d8dbf64d64db311eb2854bdf1ceb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386ac9391f31bdefc331def7359970eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a386ac9391f31bdefc331def7359970eb">setLookAt</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> eye, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> center, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> up)</td></tr>
<tr class="memdesc:a386ac9391f31bdefc331def7359970eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the view matrix so that the camera is looking at a given direction.  <a href="classtgx_1_1_renderer3_d.html#a386ac9391f31bdefc331def7359970eb">More...</a><br /></td></tr>
<tr class="separator:a386ac9391f31bdefc331def7359970eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eac08822d93c5fa419d7cc566aa636d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_vec4_8h.html#a66dc844afdc508c1137c733caa63695b">fVec4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a3eac08822d93c5fa419d7cc566aa636d">worldToViewPort</a> (<a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> P)</td></tr>
<tr class="memdesc:a3eac08822d93c5fa419d7cc566aa636d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from world coord.  <a href="classtgx_1_1_renderer3_d.html#a3eac08822d93c5fa419d7cc566aa636d">More...</a><br /></td></tr>
<tr class="separator:a3eac08822d93c5fa419d7cc566aa636d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c4ce4af7e3c7da2e3a1a7d1d0d4f01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_vec2_8h.html#a37eab41759a1a4093ac2fbde648b4c0f">iVec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a76c4ce4af7e3c7da2e3a1a7d1d0d4f01">worldToImage</a> (<a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> P)</td></tr>
<tr class="memdesc:a76c4ce4af7e3c7da2e3a1a7d1d0d4f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from world coord.  <a href="classtgx_1_1_renderer3_d.html#a76c4ce4af7e3c7da2e3a1a7d1d0d4f01">More...</a><br /></td></tr>
<tr class="separator:a76c4ce4af7e3c7da2e3a1a7d1d0d4f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594bb296fe042612d4036c04ae1e2d1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a594bb296fe042612d4036c04ae1e2d1b">setLightDirection</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;direction)</td></tr>
<tr class="memdesc:a594bb296fe042612d4036c04ae1e2d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the light source direction (i.e.  <a href="classtgx_1_1_renderer3_d.html#a594bb296fe042612d4036c04ae1e2d1b">More...</a><br /></td></tr>
<tr class="separator:a594bb296fe042612d4036c04ae1e2d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412610fe5ada143bfcf9cc017bda809d"><td class="memItemLeft" align="right" valign="top"><a id="a412610fe5ada143bfcf9cc017bda809d" name="a412610fe5ada143bfcf9cc017bda809d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setLightAmbiant</b> (const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;color)</td></tr>
<tr class="memdesc:a412610fe5ada143bfcf9cc017bda809d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the scene ambiant light color (according to the Phong lightning model). <br /></td></tr>
<tr class="separator:a412610fe5ada143bfcf9cc017bda809d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5463cb7ba2f16fa1cf184999acf7f5"><td class="memItemLeft" align="right" valign="top"><a id="aad5463cb7ba2f16fa1cf184999acf7f5" name="aad5463cb7ba2f16fa1cf184999acf7f5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setLightDiffuse</b> (const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;color)</td></tr>
<tr class="memdesc:aad5463cb7ba2f16fa1cf184999acf7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the scene diffuse light color (according to the Phong lightning model). <br /></td></tr>
<tr class="separator:aad5463cb7ba2f16fa1cf184999acf7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae01958e81972d5bdd3392fbe23eda6a"><td class="memItemLeft" align="right" valign="top"><a id="aae01958e81972d5bdd3392fbe23eda6a" name="aae01958e81972d5bdd3392fbe23eda6a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setLightSpecular</b> (const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;color)</td></tr>
<tr class="memdesc:aae01958e81972d5bdd3392fbe23eda6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the scene specular light color (according to the Phong lightning model). <br /></td></tr>
<tr class="separator:aae01958e81972d5bdd3392fbe23eda6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad40825895c5cb3a675fb15c2035d97"><td class="memItemLeft" align="right" valign="top"><a id="a5ad40825895c5cb3a675fb15c2035d97" name="a5ad40825895c5cb3a675fb15c2035d97"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setLight</b> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> direction, const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;ambiantColor, const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;diffuseColor, const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;specularColor)</td></tr>
<tr class="memdesc:a5ad40825895c5cb3a675fb15c2035d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all the parameters of the scene light source at once. <br /></td></tr>
<tr class="separator:a5ad40825895c5cb3a675fb15c2035d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca1f0b53ca7460869fc3031f8422240"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a7ca1f0b53ca7460869fc3031f8422240">setModelMatrix</a> (const <a class="el" href="_mat4_8h.html#aa543bb38f59d79a08113a6254b587322">fMat4</a> &amp;M)</td></tr>
<tr class="memdesc:a7ca1f0b53ca7460869fc3031f8422240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the model tranformation matrix.  <a href="classtgx_1_1_renderer3_d.html#a7ca1f0b53ca7460869fc3031f8422240">More...</a><br /></td></tr>
<tr class="separator:a7ca1f0b53ca7460869fc3031f8422240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92666f8cccbb7233cae2fc07322efcc3"><td class="memItemLeft" align="right" valign="top"><a id="a92666f8cccbb7233cae2fc07322efcc3" name="a92666f8cccbb7233cae2fc07322efcc3"></a>
<a class="el" href="_mat4_8h.html#aa543bb38f59d79a08113a6254b587322">fMat4</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getModelMatrix</b> () const</td></tr>
<tr class="memdesc:a92666f8cccbb7233cae2fc07322efcc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the current model matrix. <br /></td></tr>
<tr class="separator:a92666f8cccbb7233cae2fc07322efcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29025a5ef39eaf15590bdba70b0e4e9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a29025a5ef39eaf15590bdba70b0e4e9d">setModelPosScaleRot</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;center=<a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a>{ 0, 0, 0 }, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;scale=<a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a>(1, 1, 1), float rot_angle=0, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;rot_dir=<a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a>{ 0, 1, 0 })</td></tr>
<tr class="memdesc:a29025a5ef39eaf15590bdba70b0e4e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the model matrix in such way that a model centered at the origin (in model coordinate) will appear at a given position/scale/rotation on the world coordinates.  <a href="classtgx_1_1_renderer3_d.html#a29025a5ef39eaf15590bdba70b0e4e9d">More...</a><br /></td></tr>
<tr class="separator:a29025a5ef39eaf15590bdba70b0e4e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689366e55dcfab2bfb516c3d17524b3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_vec4_8h.html#a66dc844afdc508c1137c733caa63695b">fVec4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a689366e55dcfab2bfb516c3d17524b3a">modelToViewPort</a> (<a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> P)</td></tr>
<tr class="memdesc:a689366e55dcfab2bfb516c3d17524b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from model coord.  <a href="classtgx_1_1_renderer3_d.html#a689366e55dcfab2bfb516c3d17524b3a">More...</a><br /></td></tr>
<tr class="separator:a689366e55dcfab2bfb516c3d17524b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27bb400f5ad09195a860f6f7ab3db71c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_vec2_8h.html#a37eab41759a1a4093ac2fbde648b4c0f">iVec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a27bb400f5ad09195a860f6f7ab3db71c">modelToImage</a> (<a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> P)</td></tr>
<tr class="memdesc:a27bb400f5ad09195a860f6f7ab3db71c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from model coord.  <a href="classtgx_1_1_renderer3_d.html#a27bb400f5ad09195a860f6f7ab3db71c">More...</a><br /></td></tr>
<tr class="separator:a27bb400f5ad09195a860f6f7ab3db71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5452d61ed252f1ccdce87834ffd8491f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a5452d61ed252f1ccdce87834ffd8491f">setMaterialColor</a> (<a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> color)</td></tr>
<tr class="memdesc:a5452d61ed252f1ccdce87834ffd8491f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the object material color.  <a href="classtgx_1_1_renderer3_d.html#a5452d61ed252f1ccdce87834ffd8491f">More...</a><br /></td></tr>
<tr class="separator:a5452d61ed252f1ccdce87834ffd8491f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04afc9a2671e9cea42d62f0cf0c06003"><td class="memItemLeft" align="right" valign="top"><a id="a04afc9a2671e9cea42d62f0cf0c06003" name="a04afc9a2671e9cea42d62f0cf0c06003"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setMaterialAmbiantStrength</b> (float strenght=0.1f)</td></tr>
<tr class="memdesc:a04afc9a2671e9cea42d62f0cf0c06003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set how much the object material reflects the ambient light. <br /></td></tr>
<tr class="separator:a04afc9a2671e9cea42d62f0cf0c06003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b59fb15f8464b2dbc690cf9244648c"><td class="memItemLeft" align="right" valign="top"><a id="a24b59fb15f8464b2dbc690cf9244648c" name="a24b59fb15f8464b2dbc690cf9244648c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setMaterialDiffuseStrength</b> (float strenght=0.6f)</td></tr>
<tr class="memdesc:a24b59fb15f8464b2dbc690cf9244648c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set how much the object material reflects the diffuse light. <br /></td></tr>
<tr class="separator:a24b59fb15f8464b2dbc690cf9244648c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20831a50013228afa468783499f44893"><td class="memItemLeft" align="right" valign="top"><a id="a20831a50013228afa468783499f44893" name="a20831a50013228afa468783499f44893"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setMaterialSpecularStrength</b> (float strenght=0.5f)</td></tr>
<tr class="memdesc:a20831a50013228afa468783499f44893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set how much the object material reflects the specular light. <br /></td></tr>
<tr class="separator:a20831a50013228afa468783499f44893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4d3e69db91b78e7b86cfa8a239e54e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a0c4d3e69db91b78e7b86cfa8a239e54e">setMaterialSpecularExponent</a> (int exponent=16)</td></tr>
<tr class="memdesc:a0c4d3e69db91b78e7b86cfa8a239e54e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the object specular exponent.  <a href="classtgx_1_1_renderer3_d.html#a0c4d3e69db91b78e7b86cfa8a239e54e">More...</a><br /></td></tr>
<tr class="separator:a0c4d3e69db91b78e7b86cfa8a239e54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae2f4be4d9c231fdd4f8f624a80a4e8"><td class="memItemLeft" align="right" valign="top"><a id="a5ae2f4be4d9c231fdd4f8f624a80a4e8" name="a5ae2f4be4d9c231fdd4f8f624a80a4e8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setMaterial</b> (<a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> color, float ambiantStrength, float diffuseStrength, float specularStrength, int specularExponent)</td></tr>
<tr class="memdesc:a5ae2f4be4d9c231fdd4f8f624a80a4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all the object material properties all at once. <br /></td></tr>
<tr class="separator:a5ae2f4be4d9c231fdd4f8f624a80a4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0298855a66fc0063e3c935dabac4c51e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a0298855a66fc0063e3c935dabac4c51e">drawMesh</a> (const <a class="el" href="structtgx_1_1_mesh3_d.html">Mesh3D</a>&lt; color_t &gt; *mesh, bool use_mesh_material=true, bool draw_chained_meshes=true)</td></tr>
<tr class="memdesc:a0298855a66fc0063e3c935dabac4c51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a mesh onto the image.  <a href="classtgx_1_1_renderer3_d.html#a0298855a66fc0063e3c935dabac4c51e">More...</a><br /></td></tr>
<tr class="separator:a0298855a66fc0063e3c935dabac4c51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08c1eab35027a61fee8a22c68ea348d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#ad08c1eab35027a61fee8a22c68ea348d">drawTriangle</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P1, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P2, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P3, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *N1=nullptr, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *N2=nullptr, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *N3=nullptr, const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *T1=nullptr, const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *T2=nullptr, const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *T3=nullptr, const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture=nullptr)</td></tr>
<tr class="memdesc:ad08c1eab35027a61fee8a22c68ea348d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a single triangle on the image.  <a href="classtgx_1_1_renderer3_d.html#ad08c1eab35027a61fee8a22c68ea348d">More...</a><br /></td></tr>
<tr class="separator:ad08c1eab35027a61fee8a22c68ea348d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb17f3177a24fbeccbb0d8a801aef88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a7bb17f3177a24fbeccbb0d8a801aef88">drawTriangleWithVertexColor</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P1, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P2, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P3, const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;col1, const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;col2, const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;col3, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *N1=nullptr, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *N2=nullptr, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *N3=nullptr)</td></tr>
<tr class="memdesc:a7bb17f3177a24fbeccbb0d8a801aef88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a single triangle on the image with a given color on each of its vertices.  <a href="classtgx_1_1_renderer3_d.html#a7bb17f3177a24fbeccbb0d8a801aef88">More...</a><br /></td></tr>
<tr class="separator:a7bb17f3177a24fbeccbb0d8a801aef88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad54f3bb4aedeeee2efbb8aa9956bf17a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#ad54f3bb4aedeeee2efbb8aa9956bf17a">drawTriangles</a> (int nb_triangles, const uint16_t *ind_vertices, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *vertices, const uint16_t *ind_normals=nullptr, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *normals=nullptr, const uint16_t *ind_texture=nullptr, const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *textures=nullptr, const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture_image=nullptr)</td></tr>
<tr class="memdesc:ad54f3bb4aedeeee2efbb8aa9956bf17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a list of triangles on the image.  <a href="classtgx_1_1_renderer3_d.html#ad54f3bb4aedeeee2efbb8aa9956bf17a">More...</a><br /></td></tr>
<tr class="separator:ad54f3bb4aedeeee2efbb8aa9956bf17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1acda7d8cb5a16666acdb3306dcdd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#afc1acda7d8cb5a16666acdb3306dcdd3">drawQuad</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P1, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P2, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P3, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P4, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *N1=nullptr, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *N2=nullptr, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *N3=nullptr, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *N4=nullptr, const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *T1=nullptr, const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *T2=nullptr, const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *T3=nullptr, const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *T4=nullptr, const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture=nullptr)</td></tr>
<tr class="memdesc:afc1acda7d8cb5a16666acdb3306dcdd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a single quad on the image.  <a href="classtgx_1_1_renderer3_d.html#afc1acda7d8cb5a16666acdb3306dcdd3">More...</a><br /></td></tr>
<tr class="separator:afc1acda7d8cb5a16666acdb3306dcdd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addff7a6a3a439659704d29b524b7f6b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#addff7a6a3a439659704d29b524b7f6b2">drawQuadWithVertexColor</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P1, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P2, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P3, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P4, const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;col1, const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;col2, const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;col3, const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;col4, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *N1=nullptr, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *N2=nullptr, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *N3=nullptr, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *N4=nullptr)</td></tr>
<tr class="memdesc:addff7a6a3a439659704d29b524b7f6b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a single quad on the image with a given color on each of its four vertices.  <a href="classtgx_1_1_renderer3_d.html#addff7a6a3a439659704d29b524b7f6b2">More...</a><br /></td></tr>
<tr class="separator:addff7a6a3a439659704d29b524b7f6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01fe01f23d0925292db43938f164d5ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a01fe01f23d0925292db43938f164d5ad">drawQuads</a> (int nb_quads, const uint16_t *ind_vertices, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *vertices, const uint16_t *ind_normals=nullptr, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *normals=nullptr, const uint16_t *ind_texture=nullptr, const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *textures=nullptr, const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture_image=nullptr)</td></tr>
<tr class="memdesc:a01fe01f23d0925292db43938f164d5ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a list of quads on the image.  <a href="classtgx_1_1_renderer3_d.html#a01fe01f23d0925292db43938f164d5ad">More...</a><br /></td></tr>
<tr class="separator:a01fe01f23d0925292db43938f164d5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf2c28c514af367fd47964577f1584d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a8bf2c28c514af367fd47964577f1584d">drawPixel</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;pos)</td></tr>
<tr class="memdesc:a8bf2c28c514af367fd47964577f1584d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a single pixel on the image at a given position (in model space).  <a href="classtgx_1_1_renderer3_d.html#a8bf2c28c514af367fd47964577f1584d">More...</a><br /></td></tr>
<tr class="separator:a8bf2c28c514af367fd47964577f1584d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84de3cba37172959adf6f7715c330ec2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a84de3cba37172959adf6f7715c330ec2">drawPixel</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;pos, color_t color)</td></tr>
<tr class="memdesc:a84de3cba37172959adf6f7715c330ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a single pixel on the image at a given position (in model space).  <a href="classtgx_1_1_renderer3_d.html#a84de3cba37172959adf6f7715c330ec2">More...</a><br /></td></tr>
<tr class="separator:a84de3cba37172959adf6f7715c330ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7b04bab823ad980ae1680895f4ef66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a9c7b04bab823ad980ae1680895f4ef66">drawPixel</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;pos, color_t color, float opacity)</td></tr>
<tr class="memdesc:a9c7b04bab823ad980ae1680895f4ef66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a single pixel on the image at a given position (given in model space).  <a href="classtgx_1_1_renderer3_d.html#a9c7b04bab823ad980ae1680895f4ef66">More...</a><br /></td></tr>
<tr class="separator:a9c7b04bab823ad980ae1680895f4ef66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c10061203e26574e147aef75dcd2969"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a9c10061203e26574e147aef75dcd2969">drawPixels</a> (int nb_pixels, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *pos_list)</td></tr>
<tr class="memdesc:a9c10061203e26574e147aef75dcd2969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a list of pixels on the image at given positions (in model space).  <a href="classtgx_1_1_renderer3_d.html#a9c10061203e26574e147aef75dcd2969">More...</a><br /></td></tr>
<tr class="separator:a9c10061203e26574e147aef75dcd2969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36510d0870041e892f9042b0ab0da229"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a36510d0870041e892f9042b0ab0da229">drawPixels</a> (int nb_pixels, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *pos_list, const int *colors_ind, const color_t *colors)</td></tr>
<tr class="memdesc:a36510d0870041e892f9042b0ab0da229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a list of pixels on the image at given positions (in model space).  <a href="classtgx_1_1_renderer3_d.html#a36510d0870041e892f9042b0ab0da229">More...</a><br /></td></tr>
<tr class="separator:a36510d0870041e892f9042b0ab0da229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cc940d37989db78a9cdaf790000fb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#af3cc940d37989db78a9cdaf790000fb6">drawPixels</a> (int nb_pixels, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *pos_list, const int *colors_ind, const color_t *colors, const int *opacities_ind, const float *opacities)</td></tr>
<tr class="memdesc:af3cc940d37989db78a9cdaf790000fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a list of pixels on the image at given positions (in model space).  <a href="classtgx_1_1_renderer3_d.html#af3cc940d37989db78a9cdaf790000fb6">More...</a><br /></td></tr>
<tr class="separator:af3cc940d37989db78a9cdaf790000fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae965bedf9a2eb21f8a5cc7c2f389f367"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#ae965bedf9a2eb21f8a5cc7c2f389f367">drawDot</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;pos, int r)</td></tr>
<tr class="memdesc:ae965bedf9a2eb21f8a5cc7c2f389f367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a dot/circle on the image at a given position (in model space) with a given radius in screen pixels.  <a href="classtgx_1_1_renderer3_d.html#ae965bedf9a2eb21f8a5cc7c2f389f367">More...</a><br /></td></tr>
<tr class="separator:ae965bedf9a2eb21f8a5cc7c2f389f367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737023062509a8911f3deab029daccb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a737023062509a8911f3deab029daccb4">drawDot</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;pos, int r, color_t color)</td></tr>
<tr class="memdesc:a737023062509a8911f3deab029daccb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a dot/circle on the image at a given position (in model space) with a given radius in screen pixels.  <a href="classtgx_1_1_renderer3_d.html#a737023062509a8911f3deab029daccb4">More...</a><br /></td></tr>
<tr class="separator:a737023062509a8911f3deab029daccb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0459fa6b84613036c70e17fd7d944d49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a0459fa6b84613036c70e17fd7d944d49">drawDot</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;pos, int r, color_t color, float opacity)</td></tr>
<tr class="memdesc:a0459fa6b84613036c70e17fd7d944d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a dot/circle on the image at a given position (in model space).  <a href="classtgx_1_1_renderer3_d.html#a0459fa6b84613036c70e17fd7d944d49">More...</a><br /></td></tr>
<tr class="separator:a0459fa6b84613036c70e17fd7d944d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616b7d7ad47a01a821532719998c3fda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a616b7d7ad47a01a821532719998c3fda">drawDots</a> (int nb_dots, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *pos_list, const int radius)</td></tr>
<tr class="memdesc:a616b7d7ad47a01a821532719998c3fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a list of dots/circles on the image at given positions (in model space).  <a href="classtgx_1_1_renderer3_d.html#a616b7d7ad47a01a821532719998c3fda">More...</a><br /></td></tr>
<tr class="separator:a616b7d7ad47a01a821532719998c3fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09985528df359b561e8abbf524221b46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a09985528df359b561e8abbf524221b46">drawDots</a> (int nb_dots, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *pos_list, const int *radius_ind, const int *radius)</td></tr>
<tr class="memdesc:a09985528df359b561e8abbf524221b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a list of dots/circles on the image at given positions (in model space).  <a href="classtgx_1_1_renderer3_d.html#a09985528df359b561e8abbf524221b46">More...</a><br /></td></tr>
<tr class="separator:a09985528df359b561e8abbf524221b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad391f1bf45449c20528f5509603188b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#ad391f1bf45449c20528f5509603188b4">drawDots</a> (int nb_dots, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *pos_list, const int *radius_ind, const int *radius, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *colors_ind, const color_t *colors)</td></tr>
<tr class="memdesc:ad391f1bf45449c20528f5509603188b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a list of dots/circles on the image at given positions (in model space).  <a href="classtgx_1_1_renderer3_d.html#ad391f1bf45449c20528f5509603188b4">More...</a><br /></td></tr>
<tr class="separator:ad391f1bf45449c20528f5509603188b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ddcca2d8bb674777bff0ba74e314b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a31ddcca2d8bb674777bff0ba74e314b2">drawDots</a> (int nb_dots, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *pos_list, const int *radius_ind, const int *radius, const int *colors_ind, const color_t *colors, const int *opacities_ind, const float *opacities)</td></tr>
<tr class="memdesc:a31ddcca2d8bb674777bff0ba74e314b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a list of dots/circles on the image at given positions (in model space).  <a href="classtgx_1_1_renderer3_d.html#a31ddcca2d8bb674777bff0ba74e314b2">More...</a><br /></td></tr>
<tr class="separator:a31ddcca2d8bb674777bff0ba74e314b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f87bfade3e549ef8b3ec2468705e77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a44f87bfade3e549ef8b3ec2468705e77">drawCube</a> ()</td></tr>
<tr class="memdesc:a44f87bfade3e549ef8b3ec2468705e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw the cube [-1,1]^3 (in model space).  <a href="classtgx_1_1_renderer3_d.html#a44f87bfade3e549ef8b3ec2468705e77">More...</a><br /></td></tr>
<tr class="separator:a44f87bfade3e549ef8b3ec2468705e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32f027d40abe77c230d9975482d6488"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#ab32f027d40abe77c230d9975482d6488">drawCube</a> (const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> v_front_ABCD[4], const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture_front, const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> v_back_EFGH[4], const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture_back, const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> v_top_HADE[4], const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture_top, const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> v_bottom_BGFC[4], const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture_bottom, const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> v_left_HGBA[4], const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture_left, const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> v_right_DCFE[4], const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture_right)</td></tr>
<tr class="memdesc:ab32f027d40abe77c230d9975482d6488"><td class="mdescLeft">&#160;</td><td class="mdescRight">draw a textured unit cube [-1,1]^3 (in model space)  <a href="classtgx_1_1_renderer3_d.html#ab32f027d40abe77c230d9975482d6488">More...</a><br /></td></tr>
<tr class="separator:ab32f027d40abe77c230d9975482d6488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4b0d511a4144826084788e5f69911a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a2f4b0d511a4144826084788e5f69911a">drawCube</a> (const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture_front, const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture_back, const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture_top, const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture_bottom, const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture_left, const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture_right)</td></tr>
<tr class="memdesc:a2f4b0d511a4144826084788e5f69911a"><td class="mdescLeft">&#160;</td><td class="mdescRight">draw a textured unit cube [-1,1]^3 (in model space)  <a href="classtgx_1_1_renderer3_d.html#a2f4b0d511a4144826084788e5f69911a">More...</a><br /></td></tr>
<tr class="separator:a2f4b0d511a4144826084788e5f69911a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0737d0bed8e991bdda9c956e6842478d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a0737d0bed8e991bdda9c956e6842478d">drawSphere</a> (int nb_sectors, int nb_stacks)</td></tr>
<tr class="memdesc:a0737d0bed8e991bdda9c956e6842478d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a unit radius sphere centered at the origin S(0,1).  <a href="classtgx_1_1_renderer3_d.html#a0737d0bed8e991bdda9c956e6842478d">More...</a><br /></td></tr>
<tr class="separator:a0737d0bed8e991bdda9c956e6842478d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6fbb721753ca5a7f0f5237eb2ebbe01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#ae6fbb721753ca5a7f0f5237eb2ebbe01">drawSphere</a> (int nb_sectors, int nb_stacks, const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture)</td></tr>
<tr class="memdesc:ae6fbb721753ca5a7f0f5237eb2ebbe01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a textured unit radius sphere centered at the origin S(0,1).  <a href="classtgx_1_1_renderer3_d.html#ae6fbb721753ca5a7f0f5237eb2ebbe01">More...</a><br /></td></tr>
<tr class="separator:ae6fbb721753ca5a7f0f5237eb2ebbe01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c59fee77ca3d42b19d62e9eade1203"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a00c59fee77ca3d42b19d62e9eade1203">drawAdaptativeSphere</a> (float quality=1.0f)</td></tr>
<tr class="memdesc:a00c59fee77ca3d42b19d62e9eade1203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a unit radius sphere centered at the origin S(0,1).  <a href="classtgx_1_1_renderer3_d.html#a00c59fee77ca3d42b19d62e9eade1203">More...</a><br /></td></tr>
<tr class="separator:a00c59fee77ca3d42b19d62e9eade1203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9186b507df18e0df32976781d48909"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#afa9186b507df18e0df32976781d48909">drawAdaptativeSphere</a> (const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *texture, float quality=1.0f)</td></tr>
<tr class="memdesc:afa9186b507df18e0df32976781d48909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a textured unit radius sphere centered at the origin S(0,1).  <a href="classtgx_1_1_renderer3_d.html#afa9186b507df18e0df32976781d48909">More...</a><br /></td></tr>
<tr class="separator:afa9186b507df18e0df32976781d48909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae167aca012374ff0ebd009ca3a008df9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#ae167aca012374ff0ebd009ca3a008df9">drawWireFrameMesh</a> (const <a class="el" href="structtgx_1_1_mesh3_d.html">Mesh3D</a>&lt; color_t &gt; *mesh, bool draw_chained_meshes=true)</td></tr>
<tr class="memdesc:ae167aca012374ff0ebd009ca3a008df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a mesh onto the image using 'wireframe' lines (FAST BUT LOW QUALITY METHOD).  <a href="classtgx_1_1_renderer3_d.html#ae167aca012374ff0ebd009ca3a008df9">More...</a><br /></td></tr>
<tr class="separator:ae167aca012374ff0ebd009ca3a008df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c46a19d2e105e81c92f040e3d21590"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a33c46a19d2e105e81c92f040e3d21590">drawWireFrameMesh</a> (const <a class="el" href="structtgx_1_1_mesh3_d.html">Mesh3D</a>&lt; color_t &gt; *mesh, bool draw_chained_meshes, float thickness)</td></tr>
<tr class="memdesc:a33c46a19d2e105e81c92f040e3d21590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a mesh onto the image using 'wireframe' lines (HIGH QUALITY / SLOW VERSION).  <a href="classtgx_1_1_renderer3_d.html#a33c46a19d2e105e81c92f040e3d21590">More...</a><br /></td></tr>
<tr class="separator:a33c46a19d2e105e81c92f040e3d21590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b34fbcf5759c1231f31a16e98ed667e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a3b34fbcf5759c1231f31a16e98ed667e">drawWireFrameMesh</a> (const <a class="el" href="structtgx_1_1_mesh3_d.html">Mesh3D</a>&lt; color_t &gt; *mesh, bool draw_chained_meshes, float thickness, color_t color, float opacity)</td></tr>
<tr class="memdesc:a3b34fbcf5759c1231f31a16e98ed667e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a mesh onto the image using 'wireframe' lines (HIGH QUALITY / SLOW VERSION).  <a href="classtgx_1_1_renderer3_d.html#a3b34fbcf5759c1231f31a16e98ed667e">More...</a><br /></td></tr>
<tr class="separator:a3b34fbcf5759c1231f31a16e98ed667e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021ab6984464a4d7afe933d81bc5ef96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a021ab6984464a4d7afe933d81bc5ef96">drawWireFrameLine</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P1, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P2)</td></tr>
<tr class="memdesc:a021ab6984464a4d7afe933d81bc5ef96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a 'wireframe' 3D line segment (FAST BUT LOW QUALITY METHOD).  <a href="classtgx_1_1_renderer3_d.html#a021ab6984464a4d7afe933d81bc5ef96">More...</a><br /></td></tr>
<tr class="separator:a021ab6984464a4d7afe933d81bc5ef96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39fef04362e7b7d0fa48fac96d0e7261"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a39fef04362e7b7d0fa48fac96d0e7261">drawWireFrameLine</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P1, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P2, float thickness)</td></tr>
<tr class="memdesc:a39fef04362e7b7d0fa48fac96d0e7261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a 'wireframe' 3D line segment.  <a href="classtgx_1_1_renderer3_d.html#a39fef04362e7b7d0fa48fac96d0e7261">More...</a><br /></td></tr>
<tr class="separator:a39fef04362e7b7d0fa48fac96d0e7261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb9598771b00af5e8aac070b4393231"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#addb9598771b00af5e8aac070b4393231">drawWireFrameLine</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P1, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P2, float thickness, color_t color, float opacity)</td></tr>
<tr class="memdesc:addb9598771b00af5e8aac070b4393231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a 'wireframe' 3D line segment.  <a href="classtgx_1_1_renderer3_d.html#addb9598771b00af5e8aac070b4393231">More...</a><br /></td></tr>
<tr class="separator:addb9598771b00af5e8aac070b4393231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8a63bd23b32cf1887940b92a352f08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a4c8a63bd23b32cf1887940b92a352f08">drawWireFrameLines</a> (int nb_lines, const uint16_t *ind_vertices, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *vertices)</td></tr>
<tr class="memdesc:a4c8a63bd23b32cf1887940b92a352f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a list of wireframe lines on the image (FAST BUT LOW QUALITY METHOD).  <a href="classtgx_1_1_renderer3_d.html#a4c8a63bd23b32cf1887940b92a352f08">More...</a><br /></td></tr>
<tr class="separator:a4c8a63bd23b32cf1887940b92a352f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77a6841c4a696ab9d2bc34769897028"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#aa77a6841c4a696ab9d2bc34769897028">drawWireFrameLines</a> (int nb_lines, const uint16_t *ind_vertices, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *vertices, float thickness)</td></tr>
<tr class="memdesc:aa77a6841c4a696ab9d2bc34769897028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a list of wireframe lines on the image.  <a href="classtgx_1_1_renderer3_d.html#aa77a6841c4a696ab9d2bc34769897028">More...</a><br /></td></tr>
<tr class="separator:aa77a6841c4a696ab9d2bc34769897028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974433794ae62149a59273afbc50ed6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a974433794ae62149a59273afbc50ed6e">drawWireFrameLines</a> (int nb_lines, const uint16_t *ind_vertices, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *vertices, float thickness, color_t color, float opacity)</td></tr>
<tr class="memdesc:a974433794ae62149a59273afbc50ed6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a list of wireframe lines on the image.  <a href="classtgx_1_1_renderer3_d.html#a974433794ae62149a59273afbc50ed6e">More...</a><br /></td></tr>
<tr class="separator:a974433794ae62149a59273afbc50ed6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12199857bf19951674f542a578642aa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a12199857bf19951674f542a578642aa2">drawWireFrameTriangle</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P1, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P2, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P3)</td></tr>
<tr class="memdesc:a12199857bf19951674f542a578642aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a 'wireframe' triangle (FAST BUT LOW QUALITY METHOD).  <a href="classtgx_1_1_renderer3_d.html#a12199857bf19951674f542a578642aa2">More...</a><br /></td></tr>
<tr class="separator:a12199857bf19951674f542a578642aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e12e01e6480e8b3577e7810601b92c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a4e12e01e6480e8b3577e7810601b92c7">drawWireFrameTriangle</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P1, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P2, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P3, float thickness)</td></tr>
<tr class="memdesc:a4e12e01e6480e8b3577e7810601b92c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a 'wireframe' triangle.  <a href="classtgx_1_1_renderer3_d.html#a4e12e01e6480e8b3577e7810601b92c7">More...</a><br /></td></tr>
<tr class="separator:a4e12e01e6480e8b3577e7810601b92c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6d9c3a846123139123791d3f416be5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a7e6d9c3a846123139123791d3f416be5">drawWireFrameTriangle</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P1, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P2, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P3, float thickness, color_t color, float opacity)</td></tr>
<tr class="memdesc:a7e6d9c3a846123139123791d3f416be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a 'wireframe' triangle.  <a href="classtgx_1_1_renderer3_d.html#a7e6d9c3a846123139123791d3f416be5">More...</a><br /></td></tr>
<tr class="separator:a7e6d9c3a846123139123791d3f416be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbdfc3d33a5d201fd7bf8cd66d6b6e4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#afbdfc3d33a5d201fd7bf8cd66d6b6e4c">drawWireFrameTriangles</a> (int nb_triangles, const uint16_t *ind_vertices, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *vertices)</td></tr>
<tr class="memdesc:afbdfc3d33a5d201fd7bf8cd66d6b6e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a list of wireframe triangles on the image (FAST BUT LOW QUALITY METHOD).  <a href="classtgx_1_1_renderer3_d.html#afbdfc3d33a5d201fd7bf8cd66d6b6e4c">More...</a><br /></td></tr>
<tr class="separator:afbdfc3d33a5d201fd7bf8cd66d6b6e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7b1b1b062a4c4acafd7e3faf0f01a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a4d7b1b1b062a4c4acafd7e3faf0f01a6">drawWireFrameTriangles</a> (int nb_triangles, const uint16_t *ind_vertices, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *vertices, float thickness)</td></tr>
<tr class="memdesc:a4d7b1b1b062a4c4acafd7e3faf0f01a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a list of wireframe triangles on the image.  <a href="classtgx_1_1_renderer3_d.html#a4d7b1b1b062a4c4acafd7e3faf0f01a6">More...</a><br /></td></tr>
<tr class="separator:a4d7b1b1b062a4c4acafd7e3faf0f01a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5eacbe59b3e28b1991d4d35992db563"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#ae5eacbe59b3e28b1991d4d35992db563">drawWireFrameTriangles</a> (int nb_triangles, const uint16_t *ind_vertices, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *vertices, float thickness, color_t color, float opacity)</td></tr>
<tr class="memdesc:ae5eacbe59b3e28b1991d4d35992db563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a list of wireframe triangles on the image.  <a href="classtgx_1_1_renderer3_d.html#ae5eacbe59b3e28b1991d4d35992db563">More...</a><br /></td></tr>
<tr class="separator:ae5eacbe59b3e28b1991d4d35992db563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2543a39299d841a368ca5365d90a06c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a2543a39299d841a368ca5365d90a06c0">drawWireFrameQuad</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P1, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P2, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P3, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P4)</td></tr>
<tr class="memdesc:a2543a39299d841a368ca5365d90a06c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a 'wireframe' quad (FAST BUT LOW QUALITY METHOD).  <a href="classtgx_1_1_renderer3_d.html#a2543a39299d841a368ca5365d90a06c0">More...</a><br /></td></tr>
<tr class="separator:a2543a39299d841a368ca5365d90a06c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f113cd615ca861cced853b71d00b36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#ab5f113cd615ca861cced853b71d00b36">drawWireFrameQuad</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P1, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P2, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P3, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P4, float thickness)</td></tr>
<tr class="memdesc:ab5f113cd615ca861cced853b71d00b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a 'wireframe' quad.  <a href="classtgx_1_1_renderer3_d.html#ab5f113cd615ca861cced853b71d00b36">More...</a><br /></td></tr>
<tr class="separator:ab5f113cd615ca861cced853b71d00b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb256562836cddea025867ce83e836e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#abb256562836cddea025867ce83e836e5">drawWireFrameQuad</a> (const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P1, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P2, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P3, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;P4, float thickness, color_t color, float opacity)</td></tr>
<tr class="memdesc:abb256562836cddea025867ce83e836e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a 'wireframe' quad.  <a href="classtgx_1_1_renderer3_d.html#abb256562836cddea025867ce83e836e5">More...</a><br /></td></tr>
<tr class="separator:abb256562836cddea025867ce83e836e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb11a254d95e6bcd239026f61cc83dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a3bb11a254d95e6bcd239026f61cc83dc">drawWireFrameQuads</a> (int nb_quads, const uint16_t *ind_vertices, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *vertices)</td></tr>
<tr class="memdesc:a3bb11a254d95e6bcd239026f61cc83dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a list of wireframe quads on the image (FAST BUT LOW QUALITY METHOD).  <a href="classtgx_1_1_renderer3_d.html#a3bb11a254d95e6bcd239026f61cc83dc">More...</a><br /></td></tr>
<tr class="separator:a3bb11a254d95e6bcd239026f61cc83dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8b7e1b937a03c9897c14451f9bc37c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a7e8b7e1b937a03c9897c14451f9bc37c">drawWireFrameQuads</a> (int nb_quads, const uint16_t *ind_vertices, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *vertices, float thickness)</td></tr>
<tr class="memdesc:a7e8b7e1b937a03c9897c14451f9bc37c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a list of quads on the image.  <a href="classtgx_1_1_renderer3_d.html#a7e8b7e1b937a03c9897c14451f9bc37c">More...</a><br /></td></tr>
<tr class="separator:a7e8b7e1b937a03c9897c14451f9bc37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845bbd628cfd96f379f3f23d880aa60a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a845bbd628cfd96f379f3f23d880aa60a">drawWireFrameQuads</a> (int nb_quads, const uint16_t *ind_vertices, const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *vertices, float thickness, color_t color, float opacity)</td></tr>
<tr class="memdesc:a845bbd628cfd96f379f3f23d880aa60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a list of quads on the image.  <a href="classtgx_1_1_renderer3_d.html#a845bbd628cfd96f379f3f23d880aa60a">More...</a><br /></td></tr>
<tr class="separator:a845bbd628cfd96f379f3f23d880aa60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1522a8010525348deefbfe92b8a9fe53"><td class="memItemLeft" align="right" valign="top"><a id="a1522a8010525348deefbfe92b8a9fe53" name="a1522a8010525348deefbfe92b8a9fe53"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>drawWireFrameCube</b> ()</td></tr>
<tr class="memdesc:a1522a8010525348deefbfe92b8a9fe53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw the cube [0,1]^3 (in model space) in wireframe (FAST BUT LOW QUALITY METHOD). <br /></td></tr>
<tr class="separator:a1522a8010525348deefbfe92b8a9fe53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc8c9d2354940771062e6a3cc696535"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a6cc8c9d2354940771062e6a3cc696535">drawWireFrameCube</a> (float thickness)</td></tr>
<tr class="memdesc:a6cc8c9d2354940771062e6a3cc696535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw the cube [0,1]^3 (in model space) in wireframe (HIGH QUALITY / SLOW VERSION).  <a href="classtgx_1_1_renderer3_d.html#a6cc8c9d2354940771062e6a3cc696535">More...</a><br /></td></tr>
<tr class="separator:a6cc8c9d2354940771062e6a3cc696535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcbdcd49776f2d634a45138c3e8d4f82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#afcbdcd49776f2d634a45138c3e8d4f82">drawWireFrameCube</a> (float thickness, color_t color, float opacity)</td></tr>
<tr class="memdesc:afcbdcd49776f2d634a45138c3e8d4f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw the cube [0,1]^3 (in model space) in wireframe (HIGH QUALITY / SLOW VERSION).  <a href="classtgx_1_1_renderer3_d.html#afcbdcd49776f2d634a45138c3e8d4f82">More...</a><br /></td></tr>
<tr class="separator:afcbdcd49776f2d634a45138c3e8d4f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaeadf985edca06331aabd301d45a4ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#afaeadf985edca06331aabd301d45a4ad">drawWireFrameSphere</a> (int nb_sectors, int nb_stacks)</td></tr>
<tr class="memdesc:afaeadf985edca06331aabd301d45a4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a wireframe unit radius sphere centered at the origin (in model space).  <a href="classtgx_1_1_renderer3_d.html#afaeadf985edca06331aabd301d45a4ad">More...</a><br /></td></tr>
<tr class="separator:afaeadf985edca06331aabd301d45a4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a0ad4af1e016d4db8422a390620895"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a11a0ad4af1e016d4db8422a390620895">drawWireFrameSphere</a> (int nb_sectors, int nb_stacks, float thickness)</td></tr>
<tr class="memdesc:a11a0ad4af1e016d4db8422a390620895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a wireframe unit radius sphere centered at the origin (in model space).  <a href="classtgx_1_1_renderer3_d.html#a11a0ad4af1e016d4db8422a390620895">More...</a><br /></td></tr>
<tr class="separator:a11a0ad4af1e016d4db8422a390620895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497e0c79f349463357371f8502b6b9be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a497e0c79f349463357371f8502b6b9be">drawWireFrameSphere</a> (int nb_sectors, int nb_stacks, float thickness, color_t color, float opacity)</td></tr>
<tr class="memdesc:a497e0c79f349463357371f8502b6b9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a wireframe unit radius sphere centered at the origin (in model space).  <a href="classtgx_1_1_renderer3_d.html#a497e0c79f349463357371f8502b6b9be">More...</a><br /></td></tr>
<tr class="separator:a497e0c79f349463357371f8502b6b9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43cd871e326daaeb9e26a85ec7bf2de6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a43cd871e326daaeb9e26a85ec7bf2de6">drawWireFrameAdaptativeSphere</a> (float quality=1.0f)</td></tr>
<tr class="memdesc:a43cd871e326daaeb9e26a85ec7bf2de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a wireframe unit radius sphere centered at the origin (in model space).  <a href="classtgx_1_1_renderer3_d.html#a43cd871e326daaeb9e26a85ec7bf2de6">More...</a><br /></td></tr>
<tr class="separator:a43cd871e326daaeb9e26a85ec7bf2de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca2aa60b71e20399327a85813f2b470"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#adca2aa60b71e20399327a85813f2b470">drawWireFrameAdaptativeSphere</a> (float quality, float thickness)</td></tr>
<tr class="memdesc:adca2aa60b71e20399327a85813f2b470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a wireframe unit radius sphere centered at the origin (in model space).  <a href="classtgx_1_1_renderer3_d.html#adca2aa60b71e20399327a85813f2b470">More...</a><br /></td></tr>
<tr class="separator:adca2aa60b71e20399327a85813f2b470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e14dda511fab4edf94bc63096379c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtgx_1_1_renderer3_d.html#a07e14dda511fab4edf94bc63096379c3">drawWireFrameAdaptativeSphere</a> (float quality, float thickness, color_t color, float opacity)</td></tr>
<tr class="memdesc:a07e14dda511fab4edf94bc63096379c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a wireframe unit radius sphere centered at the origin (in model space).  <a href="classtgx_1_1_renderer3_d.html#a07e14dda511fab4edf94bc63096379c3">More...</a><br /></td></tr>
<tr class="separator:a07e14dda511fab4edf94bc63096379c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename color_t, int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t = float&gt;<br />
class tgx::Renderer3D&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;</div><p >Class that manages a scene and draws 3D objects onto a <code><a class="el" href="classtgx_1_1_image.html">Image</a></code>. </p>
<p >A <a class="el" href="classtgx_1_1_renderer3_d.html" title="Class that manages a scene and draws 3D objects onto a Image.">Renderer3D</a> objects creates a "virtual viewport" and provides a set of methods to draw 3D primitives onto this viewport which is then mapped to a <code><a class="el" href="classtgx_1_1_image.html">tgx::Image</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LOADED_SHADERS</td><td>list of all shaders that may be used. By default, all shaders are enabled but if is possible to select only a subset of shaders to improve rendering speed and decrease memory usage significantly. Must a <code>|</code> combination of the following flags:<ul>
<li><code>TGX_SHADER_PERSPECTIVE</code>: enable perspective projection</li>
<li><code>TGX_SHADER_ORTHO</code>: enable orthographic projection</li>
<li><code>TGX_SHADER_NOZBUFFER</code>: enable rendering without using a z-buffer</li>
<li><code>TGX_SHADER_ZBUFFER</code>: enable rendering with a z-buffer</li>
<li><code>TGX_SHADER_FLAT</code>: enable flat shading</li>
<li><code>TGX_SHADER_GOURAUD</code>: enable gouraud shading</li>
<li><code>TGX_SHADER_NOTEXTURE</code>: enable rendering without texturing</li>
<li><code>TGX_SHADER_TEXTURE_NEAREST</code>: enable rendering with texturing using point sampling</li>
<li><code>TGX_SHADER_TEXTURE_BILINEAR</code>: enable rendering with texturing using bilinear sampling</li>
<li><code>TGX_SHADER_TEXTURE_WRAP_POW2</code>: texture can use 'wrap around' mode with dimensions of texture being power of two.</li>
<li><code>TGX_SHADER_TEXTURE_CLAMP</code>: texture can use 'clamping to edge' mode.</li>
</ul>
</td></tr>
    <tr><td class="paramname">ZBUFFER_t</td><td>: Type used for storing z-buffer values. Must be either <code>float</code> or <code>uint16_t</code>. The z-buffer must be as large as the image (but can be smaller than the viewport when using an offset).<ul>
<li><code>float</code>: higher quality but requires 4 bytes per pixel.</li>
<li><code>uint16_t</code> : lower quality (z-fighting may occur) but only 2 bytes per pixel. <b>Remark</b></li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>If a drawing call is made that requires a disabled shader, or if the <a class="el" href="classtgx_1_1_renderer3_d.html" title="Class that manages a scene and draws 3D objects onto a Image.">Renderer3D</a> object state is not valid (e.g. incorrect image size, enabled but missing z-buffer...) then the drawing operation will fails silently. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a333d6126e522ba550b7ec8add6c600ad" name="a333d6126e522ba550b7ec8add6c600ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a333d6126e522ba550b7ec8add6c600ad">&#9670;&#160;</a></span>Renderer3D()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::Renderer3D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a37eab41759a1a4093ac2fbde648b4c0f">iVec2</a> &amp;&#160;</td>
          <td class="paramname"><em>viewportSize</em> = <code>{0,&#160;0}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>im</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZBUFFER_t *&#160;</td>
          <td class="paramname"><em>zbuffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p >Some parameters may be set right way (but they may be also set independantly later).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">viewportSize</td><td>(Optional) Size of the viewport. See <code><a class="el" href="classtgx_1_1_renderer3_d.html#a7222e72a480ce99a8eb3d3df2dfec0aa" title="Set the size of the viewport.">setViewportSize()</a></code>. </td></tr>
    <tr><td class="paramname">im</td><td>(Optional) the destination image. See <code><a class="el" href="classtgx_1_1_renderer3_d.html#a99e31001994fa3444b15e7037a1d5f1d" title="Set the image that will be drawn onto.">setImage()</a></code>. </td></tr>
    <tr><td class="paramname">zbuffer</td><td>(Optional) the Z-buffer. See <code><a class="el" href="classtgx_1_1_renderer3_d.html#a516e700a5470f52cbd9a82dd59f8c968" title="Set the zbuffer.">setZbuffer()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad613bdffc57596703abe1a2a47583003" name="ad613bdffc57596703abe1a2a47583003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad613bdffc57596703abe1a2a47583003">&#9670;&#160;</a></span>clearZbuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::clearZbuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the Zbuffer. </p>
<p >This method should be called before drawing a new frame to erase the previous zbuffer.</p>
<p >The zbuffer is intentionally not clear between draw() calls to enable the rendering of multiple objects on the same scene. </p>

</div>
</div>
<a id="afa9186b507df18e0df32976781d48909" name="afa9186b507df18e0df32976781d48909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa9186b507df18e0df32976781d48909">&#9670;&#160;</a></span>drawAdaptativeSphere() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawAdaptativeSphere </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>quality</em> = <code>1.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a textured unit radius sphere centered at the origin S(0,1). </p>
<p >Draw a UV-sphere where the number of sector and stacks is computed automatically according to the apparent size on the screen.</p>
<ul>
<li>quality &gt; 0 is a multiplier (typically between 0.5 and 2) used to imcrease or decrease the number of faces in the tesselation:<ul>
<li>quality &lt; 1 : decrease quality but improve speed</li>
<li>quality &gt; 1 : improve quality but decrease speed</li>
</ul>
</li>
</ul>
<p >The texture is mapped using the mercator projection.</p>
<p >*** TEXTURE DIMENSIONS MUST BE POWERS OF 2 WHEN USING 'FAST' WRAP MODE FOR TEXTURING ****</p>
<p >-&gt; Use the Model matrix to draw an ellipsoid instead and/or choose the position in world coord. </p>

</div>
</div>
<a id="a00c59fee77ca3d42b19d62e9eade1203" name="a00c59fee77ca3d42b19d62e9eade1203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c59fee77ca3d42b19d62e9eade1203">&#9670;&#160;</a></span>drawAdaptativeSphere() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawAdaptativeSphere </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>quality</em> = <code>1.0f</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a unit radius sphere centered at the origin S(0,1). </p>
<p >Draw a UV-sphere where the number of sector and stacks is computed automatically according to the apparent size on the screen.</p>
<ul>
<li>quality &gt; 0 is a multiplier (typically between 0.5 and 2) used to <br  />
 imcrease or decrease the number of faces in the tesselation:<ul>
<li>quality &lt; 1 : decrease quality but improve speed <br  />
</li>
<li>quality &gt; 1 : improve quality but decrease speed <br  />
</li>
</ul>
</li>
</ul>
<p >-&gt; Use the Model matrix to draw an ellipsoid instead and/or choose the position in world coord. </p>

</div>
</div>
<a id="a44f87bfade3e549ef8b3ec2468705e77" name="a44f87bfade3e549ef8b3ec2468705e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44f87bfade3e549ef8b3ec2468705e77">&#9670;&#160;</a></span>drawCube() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawCube </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw the cube [-1,1]^3 (in model space). </p>
<p >-&gt; Use the Model matrix to draw a rectangle and/or choose the position in world coord. </p>

</div>
</div>
<a id="ab32f027d40abe77c230d9975482d6488" name="ab32f027d40abe77c230d9975482d6488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab32f027d40abe77c230d9975482d6488">&#9670;&#160;</a></span>drawCube() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawCube </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a>&#160;</td>
          <td class="paramname"><em>v_front_ABCD</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture_front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a>&#160;</td>
          <td class="paramname"><em>v_back_EFGH</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture_back</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a>&#160;</td>
          <td class="paramname"><em>v_top_HADE</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture_top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a>&#160;</td>
          <td class="paramname"><em>v_bottom_BGFC</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture_bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a>&#160;</td>
          <td class="paramname"><em>v_left_HGBA</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a>&#160;</td>
          <td class="paramname"><em>v_right_DCFE</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture_right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>draw a textured unit cube [-1,1]^3 (in model space) </p>
<p >-&gt; Use the Model matrix to draw a rectangle and/or choose the position in world coord. H-----&mdash;E | | | top | H----------&mdash;E | | /. /| H-----&mdash;A-----&mdash;D-----&mdash;E / . top / | | | | | / . / | | left | front | right | A---------&mdash;D | right | | | | | . | | G-----&mdash;B-----&mdash;C-----&mdash;F | G .......|....F | | | . | / | bottom | | . front | / | | |. | / G-----&mdash;F B---------&mdash;C | | | back | | | H-----&mdash;E</p>
<ul>
<li>Each face may use a different texture (or set the image to nullptr to disable texturing a face).</li>
<li><p class="startli">the texture coordinate for each face are given ordered by their name (e.g. 'v_front_A_B_C_D' means vertex in order: A, B, C, D for the front face)</p>
<p class="startli">*** TEXTURE DIMENSIONS MUST BE POWERS OF 2 WHEN USING 'FAST' WRAP MODE FOR TEXTURING **** </p>
</li>
</ul>

</div>
</div>
<a id="a2f4b0d511a4144826084788e5f69911a" name="a2f4b0d511a4144826084788e5f69911a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f4b0d511a4144826084788e5f69911a">&#9670;&#160;</a></span>drawCube() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawCube </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture_front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture_back</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture_top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture_bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture_right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>draw a textured unit cube [-1,1]^3 (in model space) </p>
<p >Same as above for use the whole texture image given for each face. </p>

</div>
</div>
<a id="ae965bedf9a2eb21f8a5cc7c2f389f367" name="ae965bedf9a2eb21f8a5cc7c2f389f367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae965bedf9a2eb21f8a5cc7c2f389f367">&#9670;&#160;</a></span>drawDot() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a dot/circle on the image at a given position (in model space) with a given radius in screen pixels. </p>
<p >Use the the material color.</p>
<p >The scene lightning is ignored. </p>

</div>
</div>
<a id="a737023062509a8911f3deab029daccb4" name="a737023062509a8911f3deab029daccb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a737023062509a8911f3deab029daccb4">&#9670;&#160;</a></span>drawDot() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">color_t&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a dot/circle on the image at a given position (in model space) with a given radius in screen pixels. </p>
<p >Use the specified color instead of the material color.</p>
<p >The scene lightning is ignored. </p>

</div>
</div>
<a id="a0459fa6b84613036c70e17fd7d944d49" name="a0459fa6b84613036c70e17fd7d944d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0459fa6b84613036c70e17fd7d944d49">&#9670;&#160;</a></span>drawDot() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">color_t&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a dot/circle on the image at a given position (in model space). </p>
<p >Use the specified color and opacity and use blending</p>
<p >The scene lightning is ignored. </p>

</div>
</div>
<a id="a09985528df359b561e8abbf524221b46" name="a09985528df359b561e8abbf524221b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09985528df359b561e8abbf524221b46">&#9670;&#160;</a></span>drawDots() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawDots </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_dots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>pos_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>radius_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a list of dots/circles on the image at given positions (in model space). </p>
<p >Use the material color for all dot. Use a possible different radius for each dot.</p>
<p >The scene lightning is ignored. </p>

</div>
</div>
<a id="ad391f1bf45449c20528f5509603188b4" name="ad391f1bf45449c20528f5509603188b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad391f1bf45449c20528f5509603188b4">&#9670;&#160;</a></span>drawDots() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawDots </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_dots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>pos_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>radius_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>colors_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const color_t *&#160;</td>
          <td class="paramname"><em>colors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a list of dots/circles on the image at given positions (in model space). </p>
<p >Use a possible different radius for each dot Use a (possibly) different color for each dot.</p>
<p >The scene lightning is ignored. </p>

</div>
</div>
<a id="a31ddcca2d8bb674777bff0ba74e314b2" name="a31ddcca2d8bb674777bff0ba74e314b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ddcca2d8bb674777bff0ba74e314b2">&#9670;&#160;</a></span>drawDots() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawDots </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_dots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>pos_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>radius_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>colors_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const color_t *&#160;</td>
          <td class="paramname"><em>colors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>opacities_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>opacities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a list of dots/circles on the image at given positions (in model space). </p>
<p >Use a possible different radius for each dot Use a (possibly) different color for each dot Use a (possibly) different opacity for each dot (and use blending when drawing)</p>
<p >The scene lightning parameters are ignored. </p>

</div>
</div>
<a id="a616b7d7ad47a01a821532719998c3fda" name="a616b7d7ad47a01a821532719998c3fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616b7d7ad47a01a821532719998c3fda">&#9670;&#160;</a></span>drawDots() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawDots </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_dots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>pos_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a list of dots/circles on the image at given positions (in model space). </p>
<p >Use the material color for all dot. Use the same radius for each dot.</p>
<p >The scene lightning is ignored. </p>

</div>
</div>
<a id="a0298855a66fc0063e3c935dabac4c51e" name="a0298855a66fc0063e3c935dabac4c51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0298855a66fc0063e3c935dabac4c51e">&#9670;&#160;</a></span>drawMesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtgx_1_1_mesh3_d.html">Mesh3D</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_mesh_material</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>draw_chained_meshes</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a mesh onto the image. </p>
<hr  />
<p> THIS IS THE FASTEST METHOD FOR DRAWING AN OBJECT AND SHOULD BE USED WHENEVER POSSIBLE. </p><hr  />
<ul>
<li>mesh The mesh to draw. The meshes/vertices array/textures can be in RAM or in FLASH. Whenever possible, put vertex array and texture in RAM (or even EXTMEM).</li>
<li>use_mesh_material If true, ignore the current object material properties set in the renderer and use the mesh predefined material properties. this flag affects also all the linked meshes if draw_chained_meshes=true.</li>
<li>draw_chained_meshes If true, the meshes linked to this mesh (via the -&gt;next member) are also drawn. </li>
</ul>

</div>
</div>
<a id="a8bf2c28c514af367fd47964577f1584d" name="a8bf2c28c514af367fd47964577f1584d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf2c28c514af367fd47964577f1584d">&#9670;&#160;</a></span>drawPixel() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawPixel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a single pixel on the image at a given position (in model space). </p>
<p >Use the the material color.</p>
<p >The scene lightning is ignored. </p>

</div>
</div>
<a id="a84de3cba37172959adf6f7715c330ec2" name="a84de3cba37172959adf6f7715c330ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84de3cba37172959adf6f7715c330ec2">&#9670;&#160;</a></span>drawPixel() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawPixel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">color_t&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a single pixel on the image at a given position (in model space). </p>
<p >Use the specified color instead of the material color.</p>
<p >The scene lightning is ignored. </p>

</div>
</div>
<a id="a9c7b04bab823ad980ae1680895f4ef66" name="a9c7b04bab823ad980ae1680895f4ef66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c7b04bab823ad980ae1680895f4ef66">&#9670;&#160;</a></span>drawPixel() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawPixel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">color_t&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a single pixel on the image at a given position (given in model space). </p>
<p >Use the specified color and opacity and use blending</p>
<p >The scene lightning is ignored. </p>

</div>
</div>
<a id="a9c10061203e26574e147aef75dcd2969" name="a9c10061203e26574e147aef75dcd2969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c10061203e26574e147aef75dcd2969">&#9670;&#160;</a></span>drawPixels() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawPixels </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_pixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>pos_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a list of pixels on the image at given positions (in model space). </p>
<p >Use the material color for all pixels.</p>
<p >The scene lightning is ignored. </p>

</div>
</div>
<a id="a36510d0870041e892f9042b0ab0da229" name="a36510d0870041e892f9042b0ab0da229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36510d0870041e892f9042b0ab0da229">&#9670;&#160;</a></span>drawPixels() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawPixels </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_pixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>pos_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>colors_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const color_t *&#160;</td>
          <td class="paramname"><em>colors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a list of pixels on the image at given positions (in model space). </p>
<p >Use a (possibly) different color for each pixel. The color are given by a palette and a list of indices (one for each pixel).</p>
<p >The scene lightning is ignored. </p>

</div>
</div>
<a id="af3cc940d37989db78a9cdaf790000fb6" name="af3cc940d37989db78a9cdaf790000fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3cc940d37989db78a9cdaf790000fb6">&#9670;&#160;</a></span>drawPixels() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawPixels </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_pixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>pos_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>colors_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const color_t *&#160;</td>
          <td class="paramname"><em>colors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>opacities_ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>opacities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a list of pixels on the image at given positions (in model space). </p>
<p >Use different color/opacity for each pixel and use blending. The color and opacities are both given by a palette and a list of indices (one for each pixel)</p>
<p >The scene lightning parameters are ignored. </p>

</div>
</div>
<a id="afc1acda7d8cb5a16666acdb3306dcdd3" name="afc1acda7d8cb5a16666acdb3306dcdd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1acda7d8cb5a16666acdb3306dcdd3">&#9670;&#160;</a></span>drawQuad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawQuad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>N1</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>N2</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>N3</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>N4</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *&#160;</td>
          <td class="paramname"><em>T1</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *&#160;</td>
          <td class="paramname"><em>T2</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *&#160;</td>
          <td class="paramname"><em>T3</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *&#160;</td>
          <td class="paramname"><em>T4</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a single quad on the image. </p>
<pre class="fragment">*** THE 4 VERTEX OF A QUAD MUST ALWAYS BE CO-PLANAR ***
</pre><ul>
<li>(P1,P2,P3,P4) coordinates (in model space) of the quad to draw <pre class="fragment">           *** MAKE SURE THAT THE QUAD IS GIVEN WITH THE CORRECT WINDING ORDER ***
</pre></li>
<li><p class="startli">(N1,N2,N3,N4) normals associated with (P1, P2, P3, P4). or nullptr if not using gouraud shading</p>
<p class="startli">*** THE NORMAL VECTORS MUST HAVE UNIT NORM ***</p>
</li>
<li>(T1,T2,T3,T4) texture coords. associated with (P1, P2, P3). or nullptr if not using texturing</li>
<li>texture the texture image to use (or nullptr if unused). <pre class="fragment">        *** TEXTURE DIMENSIONS MUST BE POWERS OF 2 WHEN USING 'FAST' WRAP MODE FOR TEXTURING ****
</pre> </li>
</ul>

</div>
</div>
<a id="a01fe01f23d0925292db43938f164d5ad" name="a01fe01f23d0925292db43938f164d5ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01fe01f23d0925292db43938f164d5ad">&#9670;&#160;</a></span>drawQuads()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawQuads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_quads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>ind_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>ind_normals</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>normals</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>ind_texture</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *&#160;</td>
          <td class="paramname"><em>textures</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture_image</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a list of quads on the image. </p>
<p >If texture mapping is not used, then the current material color is used to draw the triangles. </p><pre class="fragment">*** THE 4 VERTEX OF A QUAD MUST ALWAYS BE CO-PLANAR ***
</pre><ul>
<li>nb_quads Number of quads to draw.</li>
<li><p class="startli">ind_vertices Array of vertex indexes. The length of the array is nb_quads*4 and each 4 consecutive values represent a quad.</p>
<p class="startli">*** MAKE SURE THAT THE QUADS ARE GIVEN WITH THE CORRECT WINDING ORDER ***</p>
</li>
<li>vertices The array of vertices (given in model space).</li>
<li>ind_normals [Optional] array of normal indexes. If specified, the array must have length nb_quads*4.</li>
<li>normals [Optional] The array of normals vectors (in model space). <pre class="fragment">          *** THE NORMAL VECTORS MUST HAVE UNIT NORM ***
</pre></li>
<li>ind_texture [Optional] array of texture indexes. If specified, the array must have length nb_quads*4.</li>
<li>textures [Optional] The array of texture coords.</li>
<li>texture_image [Optional] the texture image to use. <pre class="fragment">          *** TEXTURE DIMENSIONS MUST BE POWERS OF 2 WHEN USING 'FAST' WRAP MODE FOR TEXTURING ****
</pre> </li>
</ul>

</div>
</div>
<a id="addff7a6a3a439659704d29b524b7f6b2" name="addff7a6a3a439659704d29b524b7f6b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addff7a6a3a439659704d29b524b7f6b2">&#9670;&#160;</a></span>drawQuadWithVertexColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawQuadWithVertexColor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;&#160;</td>
          <td class="paramname"><em>col1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;&#160;</td>
          <td class="paramname"><em>col2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;&#160;</td>
          <td class="paramname"><em>col3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;&#160;</td>
          <td class="paramname"><em>col4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>N1</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>N2</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>N3</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>N4</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a single quad on the image with a given color on each of its four vertices. </p>
<p >The color inside the quad is obtained by linear interpolation. </p><pre class="fragment">*** THE 4 VERTEX OF A QUAD MUST ALWAYS BE CO-PLANAR ***
</pre><ul>
<li>(P1,P2,P3,P4) coordinates (in model space) of the quad to draw <pre class="fragment">        *** MAKE SURE THAT THE QUAD IS GIVEN WITH THE CORRECT WINDING ORDER ***
</pre></li>
<li>(col1,col2,col3,col4) Colors of the vertices</li>
<li><p class="startli">(N1,N2,N3,N4) normals associated with (P1, P2, P3, P4). or nullptr if not using gouraud shading.</p>
<p class="startli">*** THE NORMAL VECTORS MUST HAVE UNIT NORM *** </p>
</li>
</ul>

</div>
</div>
<a id="a0737d0bed8e991bdda9c956e6842478d" name="a0737d0bed8e991bdda9c956e6842478d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0737d0bed8e991bdda9c956e6842478d">&#9670;&#160;</a></span>drawSphere() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawSphere </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_sectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_stacks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a unit radius sphere centered at the origin S(0,1). </p>
<p >Create a UV-sphere with a given number of sector and stacks.</p>
<p >-&gt; Use the Model matrix to draw an ellipsoid instead and/or choose the position in world coord. </p>

</div>
</div>
<a id="ae6fbb721753ca5a7f0f5237eb2ebbe01" name="ae6fbb721753ca5a7f0f5237eb2ebbe01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6fbb721753ca5a7f0f5237eb2ebbe01">&#9670;&#160;</a></span>drawSphere() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawSphere </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_sectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_stacks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a textured unit radius sphere centered at the origin S(0,1). </p>
<p >Create a UV-sphere with a given number of sector and stacks.</p>
<p >The texture is mapped using the Mercator projection.</p>
<p >*** TEXTURE DIMENSIONS MUST BE POWERS OF 2 WHEN USING 'FAST' WRAP MODE FOR TEXTURING ****</p>
<p >-&gt; Use the Model matrix to draw an ellipsoid instead and/or choose the position in world coord. </p>

</div>
</div>
<a id="ad08c1eab35027a61fee8a22c68ea348d" name="ad08c1eab35027a61fee8a22c68ea348d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08c1eab35027a61fee8a22c68ea348d">&#9670;&#160;</a></span>drawTriangle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawTriangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>N1</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>N2</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>N3</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *&#160;</td>
          <td class="paramname"><em>T1</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *&#160;</td>
          <td class="paramname"><em>T2</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *&#160;</td>
          <td class="paramname"><em>T3</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a single triangle on the image. </p>
<ul>
<li>(P1,P2,P3) coordinates (in model space) of the triangle to draw <pre class="fragment">        *** MAKE SURE THAT THE TRIANGLE IS GIVEN WITH THE CORRECT WINDING ORDER ***
</pre></li>
<li><p class="startli">(N1,N2,N3) pointers to the normals associated with (P1, P2, P3). <br  />
 or nullptr if not using gouraud shading</p>
<p class="startli">*** THE NORMAL VECTORS MUST HAVE UNIT NORM ***</p>
</li>
<li>(T1,T2,T3) pointers to the texture coords. associated with (P1, P2, P3). <br  />
 or nullptr if not using texturing</li>
<li>texture pointer to the texture image to use (or nullptr if not used) <pre class="fragment">        *** TEXTURE DIMENSIONS MUST BE POWERS OF 2 WHEN USING 'FAST' WRAP MODE FOR TEXTURING ****
</pre> </li>
</ul>

</div>
</div>
<a id="ad54f3bb4aedeeee2efbb8aa9956bf17a" name="ad54f3bb4aedeeee2efbb8aa9956bf17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad54f3bb4aedeeee2efbb8aa9956bf17a">&#9670;&#160;</a></span>drawTriangles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawTriangles </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_triangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>ind_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>ind_normals</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>normals</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>ind_texture</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a21109f9665da891178228a1fb80b90b6">fVec2</a> *&#160;</td>
          <td class="paramname"><em>textures</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>texture_image</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a list of triangles on the image. </p>
<p >If texture mapping is not used, then the current material color is used to draw the triangles.</p>
<ul>
<li>nb_triangles Number of triangles to draw.</li>
<li><p class="startli">ind_vertices Array of vertex indexes. The length of the array is nb_triangles*3 and each 3 consecutive values represent a triangle.</p>
<p class="startli">*** MAKE SURE THAT THE TRIANGLES ARE GIVEN WITH THE CORRECT WINDING ORDER ***</p>
</li>
<li>vertices The array of vertices (given in model space).</li>
<li>ind_normals array of normal indexes. If specified, the array must have length nb_triangles*3.</li>
<li>normals The array of normals vectors (in model space). <pre class="fragment">          *** THE NORMAL VECTORS MUST HAVE UNIT NORM ***
</pre></li>
<li>ind_texture array of texture indexes. If specified, the array must have length nb_triangles*3.</li>
<li>textures The array of texture coords.</li>
<li>texture_image The texture image to use. <pre class="fragment">          *** TEXTURE DIMENSIONS MUST BE POWERS OF 2 WHEN USING 'FAST' WRAP MODE FOR TEXTURING ****
</pre> </li>
</ul>

</div>
</div>
<a id="a7bb17f3177a24fbeccbb0d8a801aef88" name="a7bb17f3177a24fbeccbb0d8a801aef88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb17f3177a24fbeccbb0d8a801aef88">&#9670;&#160;</a></span>drawTriangleWithVertexColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawTriangleWithVertexColor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;&#160;</td>
          <td class="paramname"><em>col1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;&#160;</td>
          <td class="paramname"><em>col2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a> &amp;&#160;</td>
          <td class="paramname"><em>col3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>N1</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>N2</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>N3</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw a single triangle on the image with a given color on each of its vertices. </p>
<p >The color inside the triangle is obtained by linear interpolation.</p>
<ul>
<li>(P1,P2,P3) coordinates (in model space) of the triangle to draw <pre class="fragment">        *** MAKE SURE THAT THE TRIANGLE IS GIVEN WITH THE CORRECT WINDING ORDER ***
</pre></li>
<li>(col1,col2,col3) Colors of the vertices.</li>
<li><p class="startli">(N1,N2,N3) normals associated with (P1, P2, P3) or nullptr if not using gouraud shading.</p>
<p class="startli">*** THE NORMAL VECTORS MUST HAVE UNIT NORM *** </p>
</li>
</ul>

</div>
</div>
<a id="adca2aa60b71e20399327a85813f2b470" name="adca2aa60b71e20399327a85813f2b470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca2aa60b71e20399327a85813f2b470">&#9670;&#160;</a></span>drawWireFrameAdaptativeSphere() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameAdaptativeSphere </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>quality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a wireframe unit radius sphere centered at the origin (in model space). </p>
<p >(HIGH QUALITY / SLOW VERSION).</p>
<p >Same as above but specify the thickness (in pixels &gt; 0.0) and use anti-aliasing.</p>
<p >*** MUCH SLOWER THAN THE VERSION WITHOUT AA/THICKNESS (AND EVEN SLOWER THAN DRAWING WITH SHADERS !) *** </p>

</div>
</div>
<a id="a07e14dda511fab4edf94bc63096379c3" name="a07e14dda511fab4edf94bc63096379c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e14dda511fab4edf94bc63096379c3">&#9670;&#160;</a></span>drawWireFrameAdaptativeSphere() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameAdaptativeSphere </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>quality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">color_t&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a wireframe unit radius sphere centered at the origin (in model space). </p>
<p >(HIGH QUALITY / SLOW VERSION).</p>
<p >Same as above but specify the thickness (in pixels &gt; 0.0) and use anti-aliasing. Also set the color and opacity for blending instead of using the material color.</p>
<p >*** MUCH SLOWER THAN THE VERSION WITHOUT AA/THICKNESS (AND EVEN SLOWER THAN DRAWING WITH SHADERS !) *** </p>

</div>
</div>
<a id="a43cd871e326daaeb9e26a85ec7bf2de6" name="a43cd871e326daaeb9e26a85ec7bf2de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43cd871e326daaeb9e26a85ec7bf2de6">&#9670;&#160;</a></span>drawWireFrameAdaptativeSphere() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameAdaptativeSphere </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>quality</em> = <code>1.0f</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a wireframe unit radius sphere centered at the origin (in model space). </p>
<p >(FAST BUT LOW QUALITY METHOD).</p>
<p >Draw a UV-sphere wherethe number of sector and stacks is computed automatically according to the apparent size on the screen.</p>
<ul>
<li>quality &gt; 0 is a multiplier (typically between 0.5 and 2) used to imcrease or decrease the number of faces in the tesselation:<ul>
<li>quality &lt; 1 : decrease quality but improve speed</li>
<li>quality &gt; 1 : improve quality but decrease speed</li>
</ul>
</li>
</ul>
<p >As usual, model-view transform is applied a drawing time. </p>

</div>
</div>
<a id="a6cc8c9d2354940771062e6a3cc696535" name="a6cc8c9d2354940771062e6a3cc696535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc8c9d2354940771062e6a3cc696535">&#9670;&#160;</a></span>drawWireFrameCube() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameCube </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thickness</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw the cube [0,1]^3 (in model space) in wireframe (HIGH QUALITY / SLOW VERSION). </p>
<p >Same as above but specify the thickness (in pixels &gt; 0.0) and use anti-aliasing.</p>
<p >*** MUCH SLOWER THAN THE VERSION WITHOUT AA/THICKNESS (AND EVEN SLOWER THAN DRAWING WITH SHADERS !) *** </p>

</div>
</div>
<a id="afcbdcd49776f2d634a45138c3e8d4f82" name="afcbdcd49776f2d634a45138c3e8d4f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcbdcd49776f2d634a45138c3e8d4f82">&#9670;&#160;</a></span>drawWireFrameCube() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameCube </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">color_t&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw the cube [0,1]^3 (in model space) in wireframe (HIGH QUALITY / SLOW VERSION). </p>
<p >Same as above but specify the thickness (in pixels &gt; 0.0) and use anti-aliasing. Also set the color and opacity for blending instead of using the material color.</p>
<p >*** MUCH SLOWER THAN THE VERSION WITHOUT AA/THICKNESS (AND EVEN SLOWER THAN DRAWING WITH SHADERS !) *** </p>

</div>
</div>
<a id="a021ab6984464a4d7afe933d81bc5ef96" name="a021ab6984464a4d7afe933d81bc5ef96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a021ab6984464a4d7afe933d81bc5ef96">&#9670;&#160;</a></span>drawWireFrameLine() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameLine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a 'wireframe' 3D line segment (FAST BUT LOW QUALITY METHOD). </p>
<p >the line is drawn with the current material color. This method does not require a zbuffer.</p>
<ul>
<li>(P1, P2) coordinates (in model space) of the segment to draw. </li>
</ul>

</div>
</div>
<a id="a39fef04362e7b7d0fa48fac96d0e7261" name="a39fef04362e7b7d0fa48fac96d0e7261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39fef04362e7b7d0fa48fac96d0e7261">&#9670;&#160;</a></span>drawWireFrameLine() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameLine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a 'wireframe' 3D line segment. </p>
<p >(HIGH QUALITY / SLOW VERSION).</p>
<p >Same as above but specify the thickness (in pixels &gt; 0.0) and use anti-aliasing.</p>
<p >*** MUCH SLOWER THAN THE VERSION WITHOUT AA/THICKNESS (AND EVEN SLOWER THAN DRAWING WITH SHADERS !) *** </p>

</div>
</div>
<a id="addb9598771b00af5e8aac070b4393231" name="addb9598771b00af5e8aac070b4393231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb9598771b00af5e8aac070b4393231">&#9670;&#160;</a></span>drawWireFrameLine() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameLine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">color_t&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a 'wireframe' 3D line segment. </p>
<p >(HIGH QUALITY / SLOW VERSION).</p>
<p >Same as above but specify the thickness (in pixels &gt; 0.0) and use anti-aliasing. Also set the color and opacity for blending instead of using the material color.</p>
<p >*** MUCH SLOWER THAN THE VERSION WITHOUT AA/THICKNESS (AND EVEN SLOWER THAN DRAWING WITH SHADERS !) *** </p>

</div>
</div>
<a id="a4c8a63bd23b32cf1887940b92a352f08" name="a4c8a63bd23b32cf1887940b92a352f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8a63bd23b32cf1887940b92a352f08">&#9670;&#160;</a></span>drawWireFrameLines() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameLines </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>ind_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a list of wireframe lines on the image (FAST BUT LOW QUALITY METHOD). </p>
<p >the lines are drawn with the current material color. This method does not require a zbuffer.</p>
<ul>
<li>nb_lines Number of lines to draw.</li>
<li>ind_vertices Array of vertex indexes. The length of the array is nb_lines*2 and each 2 consecutive values represent a line segment.</li>
<li>vertices The array of vertices (given in model space). </li>
</ul>

</div>
</div>
<a id="aa77a6841c4a696ab9d2bc34769897028" name="aa77a6841c4a696ab9d2bc34769897028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa77a6841c4a696ab9d2bc34769897028">&#9670;&#160;</a></span>drawWireFrameLines() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameLines </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>ind_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a list of wireframe lines on the image. </p>
<p >(HIGH QUALITY / SLOW VERSION).</p>
<p >Same as above but specify the thickness (in pixels &gt; 0.0) and use anti-aliasing.</p>
<p >*** MUCH SLOWER THAN THE VERSION WITHOUT AA/THICKNESS (AND EVEN SLOWER THAN DRAWING WITH SHADERS !) *** </p>

</div>
</div>
<a id="a974433794ae62149a59273afbc50ed6e" name="a974433794ae62149a59273afbc50ed6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a974433794ae62149a59273afbc50ed6e">&#9670;&#160;</a></span>drawWireFrameLines() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameLines </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>ind_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">color_t&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a list of wireframe lines on the image. </p>
<p >(HIGH QUALITY / SLOW VERSION).</p>
<p >Same as above but specify the thickness (in pixels &gt; 0.0) and use anti-aliasing. Also set the color and opacity for blending instead of using the material color.</p>
<p >*** MUCH SLOWER THAN THE VERSION WITHOUT AA/THICKNESS (AND EVEN SLOWER THAN DRAWING WITH SHADERS !) *** </p>

</div>
</div>
<a id="a33c46a19d2e105e81c92f040e3d21590" name="a33c46a19d2e105e81c92f040e3d21590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33c46a19d2e105e81c92f040e3d21590">&#9670;&#160;</a></span>drawWireFrameMesh() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtgx_1_1_mesh3_d.html">Mesh3D</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>draw_chained_meshes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a mesh onto the image using 'wireframe' lines (HIGH QUALITY / SLOW VERSION). </p>
<p >Same as above but specify the thickness (in pixels &gt; 0.0) and use anti-aliasing.</p>
<p >*** MUCH SLOWER THAN THE VERSION WITHOUT AA/THICKNESS (AND EVEN SLOWER THAN DRAWING WITH SHADERS !) *** </p>

</div>
</div>
<a id="a3b34fbcf5759c1231f31a16e98ed667e" name="a3b34fbcf5759c1231f31a16e98ed667e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b34fbcf5759c1231f31a16e98ed667e">&#9670;&#160;</a></span>drawWireFrameMesh() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtgx_1_1_mesh3_d.html">Mesh3D</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>draw_chained_meshes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">color_t&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a mesh onto the image using 'wireframe' lines (HIGH QUALITY / SLOW VERSION). </p>
<p >Same as above but specify the thickness (in pixels &gt; 0.0) and use anti-aliasing. Also set the color and opacity for blending instead of using the material color.</p>
<p >*** MUCH SLOWER THAN THE VERSION WITHOUT AA/THICKNESS (AND EVEN SLOWER THAN DRAWING WITH SHADERS !) *** </p>

</div>
</div>
<a id="ae167aca012374ff0ebd009ca3a008df9" name="ae167aca012374ff0ebd009ca3a008df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae167aca012374ff0ebd009ca3a008df9">&#9670;&#160;</a></span>drawWireFrameMesh() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtgx_1_1_mesh3_d.html">Mesh3D</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>draw_chained_meshes</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a mesh onto the image using 'wireframe' lines (FAST BUT LOW QUALITY METHOD). </p>
<p >The mesh is drawn with the current material color (not that of the mesh). This method does not require a zbuffer but back face culling is used if it is enabled.</p>
<ul>
<li>mesh: The mesh to draw. The meshes/vertices array/textures can be in RAM or in FLASH. Whenever possible, put vertex array and texture in RAM (or even EXTMEM).</li>
<li>draw_chained_meshes: If true, the meshes linked to this mesh (via the -&gt;next member) are also drawn. </li>
</ul>

</div>
</div>
<a id="a2543a39299d841a368ca5365d90a06c0" name="a2543a39299d841a368ca5365d90a06c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2543a39299d841a368ca5365d90a06c0">&#9670;&#160;</a></span>drawWireFrameQuad() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameQuad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a 'wireframe' quad (FAST BUT LOW QUALITY METHOD). </p>
<p >the quad is drawn with the current material color. This method does not require a zbuffer but back face culling is used (if enabled).</p>
<ul>
<li>(P1, P2, P3, P4) coordinates (in model space) of the quad to draw. </li>
</ul>

</div>
</div>
<a id="ab5f113cd615ca861cced853b71d00b36" name="ab5f113cd615ca861cced853b71d00b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f113cd615ca861cced853b71d00b36">&#9670;&#160;</a></span>drawWireFrameQuad() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameQuad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a 'wireframe' quad. </p>
<p >(HIGH QUALITY / SLOW VERSION).</p>
<p >Same as above but specify the thickness (in pixels &gt; 0.0) and use anti-aliasing.</p>
<p >*** MUCH SLOWER THAN THE VERSION WITHOUT AA/THICKNESS (AND EVEN SLOWER THAN DRAWING WITH SHADERS !) *** </p>

</div>
</div>
<a id="abb256562836cddea025867ce83e836e5" name="abb256562836cddea025867ce83e836e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb256562836cddea025867ce83e836e5">&#9670;&#160;</a></span>drawWireFrameQuad() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameQuad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">color_t&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a 'wireframe' quad. </p>
<p >(HIGH QUALITY / SLOW VERSION).</p>
<p >Same as above but specify the thickness (in pixels &gt; 0.0) and use anti-aliasing. Also set the color and opacity for blending instead of using the material color.</p>
<p >*** MUCH SLOWER THAN THE VERSION WITHOUT AA/THICKNESS (AND EVEN SLOWER THAN DRAWING WITH SHADERS !) *** </p>

</div>
</div>
<a id="a3bb11a254d95e6bcd239026f61cc83dc" name="a3bb11a254d95e6bcd239026f61cc83dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb11a254d95e6bcd239026f61cc83dc">&#9670;&#160;</a></span>drawWireFrameQuads() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameQuads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_quads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>ind_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a list of wireframe quads on the image (FAST BUT LOW QUALITY METHOD). </p>
<p >the quads are drawn with the current material color. This method does not require a zbuffer but back face culling is used (if enabled).</p>
<ul>
<li>nb_quads Number of triangles to draw.</li>
<li><p class="startli">ind_vertices Array of vertex indexes. The length of the array is nb_triangles*3 and each 3 consecutive values represent a triangle.</p>
<p class="startli">*** MAKE SURE THAT THE QUADS ARE GIVEN WITH THE CORRECT WINDING ORDER *** *** QUADS MUST BE COPLANAR ***</p>
</li>
<li>vertices The array of vertices (given in model space). </li>
</ul>

</div>
</div>
<a id="a7e8b7e1b937a03c9897c14451f9bc37c" name="a7e8b7e1b937a03c9897c14451f9bc37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e8b7e1b937a03c9897c14451f9bc37c">&#9670;&#160;</a></span>drawWireFrameQuads() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameQuads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_quads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>ind_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a list of quads on the image. </p>
<p >(HIGH QUALITY / SLOW VERSION).</p>
<p >Same as above but specify the thickness (in pixels &gt; 0.0) and use anti-aliasing.</p>
<p >*** MUCH SLOWER THAN THE VERSION WITHOUT AA/THICKNESS (AND EVEN SLOWER THAN DRAWING WITH SHADERS !) *** </p>

</div>
</div>
<a id="a845bbd628cfd96f379f3f23d880aa60a" name="a845bbd628cfd96f379f3f23d880aa60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845bbd628cfd96f379f3f23d880aa60a">&#9670;&#160;</a></span>drawWireFrameQuads() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameQuads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_quads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>ind_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">color_t&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a list of quads on the image. </p>
<p >(HIGH QUALITY / SLOW VERSION).</p>
<p >Same as above but specify the thickness (in pixels &gt; 0.0) and use anti-aliasing. Also set the color and opacity for blending instead of using the material color.</p>
<p >*** MUCH SLOWER THAN THE VERSION WITHOUT AA/THICKNESS (AND EVEN SLOWER THAN DRAWING WITH SHADERS !) *** </p>

</div>
</div>
<a id="afaeadf985edca06331aabd301d45a4ad" name="afaeadf985edca06331aabd301d45a4ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaeadf985edca06331aabd301d45a4ad">&#9670;&#160;</a></span>drawWireFrameSphere() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameSphere </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_sectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_stacks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a wireframe unit radius sphere centered at the origin (in model space). </p>
<p >(FAST BUT LOW QUALITY METHOD).</p>
<p >Create a UV-sphere with a given number of sector and stacks. </p>

</div>
</div>
<a id="a11a0ad4af1e016d4db8422a390620895" name="a11a0ad4af1e016d4db8422a390620895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11a0ad4af1e016d4db8422a390620895">&#9670;&#160;</a></span>drawWireFrameSphere() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameSphere </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_sectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_stacks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a wireframe unit radius sphere centered at the origin (in model space). </p>
<p >(HIGH QUALITY / SLOW VERSION).</p>
<p >Same as above but specify the thickness (in pixels &gt; 0.0) and use anti-aliasing.</p>
<p >*** MUCH SLOWER THAN THE VERSION WITHOUT AA/THICKNESS (AND EVEN SLOWER THAN DRAWING WITH SHADERS !) *** </p>

</div>
</div>
<a id="a497e0c79f349463357371f8502b6b9be" name="a497e0c79f349463357371f8502b6b9be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a497e0c79f349463357371f8502b6b9be">&#9670;&#160;</a></span>drawWireFrameSphere() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameSphere </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_sectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_stacks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">color_t&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a wireframe unit radius sphere centered at the origin (in model space). </p>
<p >(HIGH QUALITY / SLOW VERSION).</p>
<p >Same as above but specify the thickness (in pixels &gt; 0.0) and use anti-aliasing. Also set the color and opacity for blending instead of using the material color.</p>
<p >*** MUCH SLOWER THAN THE VERSION WITHOUT AA/THICKNESS (AND EVEN SLOWER THAN DRAWING WITH SHADERS !) *** </p>

</div>
</div>
<a id="a12199857bf19951674f542a578642aa2" name="a12199857bf19951674f542a578642aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12199857bf19951674f542a578642aa2">&#9670;&#160;</a></span>drawWireFrameTriangle() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameTriangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a 'wireframe' triangle (FAST BUT LOW QUALITY METHOD). </p>
<p >the triangle is drawn with the current material color. This method does not require a zbuffer but back face culling is used (if enabled).</p>
<ul>
<li>(P1, P2, P3) coordinates (in model space) of the triangle to draw. </li>
</ul>

</div>
</div>
<a id="a4e12e01e6480e8b3577e7810601b92c7" name="a4e12e01e6480e8b3577e7810601b92c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e12e01e6480e8b3577e7810601b92c7">&#9670;&#160;</a></span>drawWireFrameTriangle() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameTriangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a 'wireframe' triangle. </p>
<p >(HIGH QUALITY / SLOW VERSION).</p>
<p >Same as above but specify the thickness (in pixels &gt; 0.0) and use anti-aliasing.</p>
<p >*** MUCH SLOWER THAN THE VERSION WITHOUT AA/THICKNESS (AND EVEN SLOWER THAN DRAWING WITH SHADERS !) *** </p>

</div>
</div>
<a id="a7e6d9c3a846123139123791d3f416be5" name="a7e6d9c3a846123139123791d3f416be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e6d9c3a846123139123791d3f416be5">&#9670;&#160;</a></span>drawWireFrameTriangle() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameTriangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">color_t&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a 'wireframe' triangle. </p>
<p >(HIGH QUALITY / SLOW VERSION).</p>
<p >Same as above but specify the thickness (in pixels &gt; 0.0) and use anti-aliasing. Also set the color and opacity for blending instead of using the material color.</p>
<p >*** MUCH SLOWER THAN THE VERSION WITHOUT AA/THICKNESS (AND EVEN SLOWER THAN DRAWING WITH SHADERS !) *** </p>

</div>
</div>
<a id="afbdfc3d33a5d201fd7bf8cd66d6b6e4c" name="afbdfc3d33a5d201fd7bf8cd66d6b6e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbdfc3d33a5d201fd7bf8cd66d6b6e4c">&#9670;&#160;</a></span>drawWireFrameTriangles() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameTriangles </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_triangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>ind_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a list of wireframe triangles on the image (FAST BUT LOW QUALITY METHOD). </p>
<p >the triangles are drawn with the current material color. This method does not require a zbuffer. but back face culling is used (if enabled).</p>
<ul>
<li>nb_triangles Number of triangles to draw.</li>
<li><p class="startli">ind_vertices Array of vertex indexes. The length of the array is nb_triangles*3 and each 3 consecutive values represent a triangle.</p>
<p class="startli">*** MAKE SURE THAT THE TRIANGLES ARE GIVEN WITH THE CORRECT WINDING ORDER ***</p>
</li>
<li>vertices The array of vertices (given in model space). </li>
</ul>

</div>
</div>
<a id="a4d7b1b1b062a4c4acafd7e3faf0f01a6" name="a4d7b1b1b062a4c4acafd7e3faf0f01a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7b1b1b062a4c4acafd7e3faf0f01a6">&#9670;&#160;</a></span>drawWireFrameTriangles() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameTriangles </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_triangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>ind_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a list of wireframe triangles on the image. </p>
<p >(HIGH QUALITY / SLOW VERSION).</p>
<p >Same as above but specify the thickness (in pixels &gt; 0.0) and use anti-aliasing.</p>
<p >*** MUCH SLOWER THAN THE VERSION WITHOUT AA/THICKNESS (AND EVEN SLOWER THAN DRAWING WITH SHADERS !) *** </p>

</div>
</div>
<a id="ae5eacbe59b3e28b1991d4d35992db563" name="ae5eacbe59b3e28b1991d4d35992db563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5eacbe59b3e28b1991d4d35992db563">&#9670;&#160;</a></span>drawWireFrameTriangles() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::drawWireFrameTriangles </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_triangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>ind_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">color_t&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a list of wireframe triangles on the image. </p>
<p >(HIGH QUALITY / SLOW VERSION).</p>
<p >Same as above but specify the thickness (in pixels &gt; 0.0) and use anti-aliasing. Also set the color and opacity for blending instead of using the material color.</p>
<p >*** MUCH SLOWER THAN THE VERSION WITHOUT AA/THICKNESS (AND EVEN SLOWER THAN DRAWING WITH SHADERS !) *** </p>

</div>
</div>
<a id="a27bb400f5ad09195a860f6f7ab3db71c" name="a27bb400f5ad09195a860f6f7ab3db71c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27bb400f5ad09195a860f6f7ab3db71c">&#9670;&#160;</a></span>modelToImage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_vec2_8h.html#a37eab41759a1a4093ac2fbde648b4c0f">iVec2</a> <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::modelToImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a>&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert from model coord. </p>
<p >to the corresponding image pixel.</p>
<ul>
<li>P : point given in the model coordinate system.</li>
</ul>
<p >Return the position of the associated pixel on the image. </p>

</div>
</div>
<a id="a689366e55dcfab2bfb516c3d17524b3a" name="a689366e55dcfab2bfb516c3d17524b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689366e55dcfab2bfb516c3d17524b3a">&#9670;&#160;</a></span>modelToViewPort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_vec4_8h.html#a66dc844afdc508c1137c733caa63695b">fVec4</a> <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::modelToViewPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a>&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert from model coord. </p>
<p >to the standard viewport coord.</p>
<ul>
<li>P : point given in the model coordinate system. <br  />
</li>
</ul>
<p >Return the projection of P on the standard viewport [-1,1]^2 according to the current position of the camera.</p>
<p >Note: the .w value can be used for depth testing. </p>

</div>
</div>
<a id="a76fa32770476cd15f717d3f103fd752d" name="a76fa32770476cd15f717d3f103fd752d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76fa32770476cd15f717d3f103fd752d">&#9670;&#160;</a></span>setCulling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setCulling </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the face culling strategy. </p>
<ul>
<li>w &gt; 0 : Vertices in front faces are ordered counter-clockwise CCW [default]. Clockwise faces are culled.</li>
<li>w &lt; 0 : Vertices in front faces are ordered clockwise (CW). Counter-clockwise faces are culled.</li>
<li>w = 0 : Disable face culling: both clockwise and counter-clockwise faces are drawn.</li>
</ul>
<p >Remark: - When face culling is enabled (w != 0), and when gouraud shading is active, the normal vectors supplied for the vertices must, of course, be the normal vectors for the front side of the triangle.</p><ul>
<li>When face culling is disabled (w = 0). Both face of a triangle are drawn so there is no more notion of 'front' and 'back' face. In this case, when using gouraud shading, by convention, the normal vector supplied must be those corresponding to the counter-clockwise face being shown (whatever this means since these normals vector are attached to vertices and not faces anyway, but still...) </li>
</ul>

</div>
</div>
<a id="af0ae032c0be73580be8e61c53ad42545" name="af0ae032c0be73580be8e61c53ad42545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ae032c0be73580be8e61c53ad42545">&#9670;&#160;</a></span>setFrustum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setFrustum </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>zNear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>zFar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the projection matrix as a perspective matrix <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFrustum.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFrustum.xml</a>. </p>
<p >This method automatically switches to perspective projection mode.</p>
<p >IMPORTANT :In view space, the camera is assumed to be centered at the origin, looking looking toward the negative Z axis with the Y axis pointing up (as in opengl). </p>

</div>
</div>
<a id="a99e31001994fa3444b15e7037a1d5f1d" name="a99e31001994fa3444b15e7037a1d5f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e31001994fa3444b15e7037a1d5f1d">&#9670;&#160;</a></span>setImage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtgx_1_1_image.html">Image</a>&lt; color_t &gt; *&#160;</td>
          <td class="paramname"><em>im</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the image that will be drawn onto. </p>
<p ><b>Note</b></p>
<ul>
<li>The image can be smaller than the viewport. In this case, use <code><a class="el" href="classtgx_1_1_renderer3_d.html#afc1eaf179bc6573ab508ab3a7e38dab9" title="Set the offset of the image relative to the viewport.">setOffset()</a></code> to select the portion of the viewport that will be drawn.</li>
<li>Passing <code>nullptr</code> remove the current image (and disables all drawing operation <br  />
 until a new image is inserted). </li>
</ul>

</div>
</div>
<a id="a594bb296fe042612d4036c04ae1e2d1b" name="a594bb296fe042612d4036c04ae1e2d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a594bb296fe042612d4036c04ae1e2d1b">&#9670;&#160;</a></span>setLightDirection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setLightDirection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>direction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the light source direction (i.e. </p>
<p >the direction the light points to). Direction is given in world coordinates (hence transformed by the view Matrix at rendering time so that the light does not move with the camera). </p>

</div>
</div>
<a id="a386ac9391f31bdefc331def7359970eb" name="a386ac9391f31bdefc331def7359970eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386ac9391f31bdefc331def7359970eb">&#9670;&#160;</a></span>setLookAt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setLookAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a>&#160;</td>
          <td class="paramname"><em>eye</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a>&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a>&#160;</td>
          <td class="paramname"><em>up</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the view matrix so that the camera is looking at a given direction. </p>
<p ><a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluLookAt.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluLookAt.xml</a></p>
<p >eye position of the camera in world space coords. center point the camera is looking toward in world space coords. up vector that tells the up direction for the camera (in world space coords). </p>

</div>
</div>
<a id="abd6d8dbf64d64db311eb2854bdf1ceb1" name="abd6d8dbf64d64db311eb2854bdf1ceb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd6d8dbf64d64db311eb2854bdf1ceb1">&#9670;&#160;</a></span>setLookAt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setLookAt </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>eyeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>eyeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>eyeZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>centerX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>centerY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>centerZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>upX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>upY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>upZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the view matrix so that the camera is looking at a given direction. </p>
<p ><a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluLookAt.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluLookAt.xml</a></p>
<p >eye position of the camera in world space coords. center point the camera is looking toward in world space coords. up vector that tells the up direction for the camera (in world space coords). </p>

</div>
</div>
<a id="a5452d61ed252f1ccdce87834ffd8491f" name="a5452d61ed252f1ccdce87834ffd8491f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5452d61ed252f1ccdce87834ffd8491f">&#9670;&#160;</a></span>setMaterialColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setMaterialColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtgx_1_1_r_g_bf.html">RGBf</a>&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the object material color. </p>
<p >This is the color used to render the object when texturing is not used. </p>

</div>
</div>
<a id="a0c4d3e69db91b78e7b86cfa8a239e54e" name="a0c4d3e69db91b78e7b86cfa8a239e54e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c4d3e69db91b78e7b86cfa8a239e54e">&#9670;&#160;</a></span>setMaterialSpecularExponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setMaterialSpecularExponent </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>exponent</em> = <code>16</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the object specular exponent. </p>
<p >Between 0 (no specular lightning) and 100 (very localized/glossy). </p>

</div>
</div>
<a id="a7ca1f0b53ca7460869fc3031f8422240" name="a7ca1f0b53ca7460869fc3031f8422240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca1f0b53ca7460869fc3031f8422240">&#9670;&#160;</a></span>setModelMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setModelMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_mat4_8h.html#aa543bb38f59d79a08113a6254b587322">fMat4</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the model tranformation matrix. </p>
<p >This matrix describes the transformation from local object space to view space. (i.e. the matrix specifies the position of the object in world space). </p>

</div>
</div>
<a id="a29025a5ef39eaf15590bdba70b0e4e9d" name="a29025a5ef39eaf15590bdba70b0e4e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29025a5ef39eaf15590bdba70b0e4e9d">&#9670;&#160;</a></span>setModelPosScaleRot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setModelPosScaleRot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a>{&#160;0,0,0&#160;}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em> = <code><a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a>(1,&#160;1,&#160;1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rot_angle</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>rot_dir</em> = <code><a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a>{&#160;0,1,0&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the model matrix in such way that a model centered at the origin (in model coordinate) will appear at a given position/scale/rotation on the world coordinates. </p>
<p >Transform are done in the following order:</p>
<p >(1) model is scaled in each direction in the model coord. according to 'scale' (2) model is rotated in model coord. around direction 'rot_dir' and with an angle 'rot_angle' (in degree). (3) model is translated to position 'center' in the world coord. </p>

</div>
</div>
<a id="aae4fa24bc6a4c5235df0ae3e112c48b3" name="aae4fa24bc6a4c5235df0ae3e112c48b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4fa24bc6a4c5235df0ae3e112c48b3">&#9670;&#160;</a></span>setOffset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a37eab41759a1a4093ac2fbde648b4c0f">iVec2</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the offset of the image relative to the viewport. </p>
<p >Same as <code><a class="el" href="classtgx_1_1_renderer3_d.html#afc1eaf179bc6573ab508ab3a7e38dab9" title="Set the offset of the image relative to the viewport.">setOffset(int ox, int oy)</a></code>. </p>

</div>
</div>
<a id="afc1eaf179bc6573ab508ab3a7e38dab9" name="afc1eaf179bc6573ab508ab3a7e38dab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1eaf179bc6573ab508ab3a7e38dab9">&#9670;&#160;</a></span>setOffset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setOffset </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>oy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the offset of the image relative to the viewport. </p>
<p >If the image has size <code>(sx,sy)</code>, then during rasterization the portion <code>[ox, ox + sx[x[oy, oy+sy[</code> of the viewport will be drawn onto the image.</p>
<p >By changing the offset and redrawing several times it it possible to use an image smaller than the viewport (and also save on zbuffer space).</p>
<p >For example, to draw a 320x240 viewport with limited amount of memory. One can use an image of size 160x120 (37.5kb) and a z-buffer of the same size (35Kb for uint16_t) and then call the drawing method 4 times with offsets (0,0), (0,120), (160,0) and (160,120) and upload the resulting images at their correct positions on the screen between each rendering.</p>
<p ><b>Note</b> Do not forget to clear the z-buffer after changing the offset ! </p>

</div>
</div>
<a id="a8ff9976b53c527e62c95be427620685f" name="a8ff9976b53c527e62c95be427620685f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff9976b53c527e62c95be427620685f">&#9670;&#160;</a></span>setOrtho()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setOrtho </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>zNear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>zFar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the projection matrix as an orthographic matrix: <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml</a>. </p>
<p >This method automatically switches to orthographic projection mode.</p>
<p >IMPORTANT :In view space, the camera is assumed to be centered at the origin, looking looking toward the negative Z axis with the Y axis pointing up (as in opengl). </p>

</div>
</div>
<a id="a8437622c6b90f9429769504848d22456" name="a8437622c6b90f9429769504848d22456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8437622c6b90f9429769504848d22456">&#9670;&#160;</a></span>setPerspective()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setPerspective </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fovy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>aspect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>zNear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>zFar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the projection matrix as a perspective matrix <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml</a>. </p>
<p >This method is only available when ORTHO = false.</p>
<p >IMPORTANT :In view space, the camera is assumed to be centered at the origin, looking looking toward the negative Z axis with the Y axis pointing up (as in opengl). </p>

</div>
</div>
<a id="af0c31304f8ec4425401629a7846adff5" name="af0c31304f8ec4425401629a7846adff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0c31304f8ec4425401629a7846adff5">&#9670;&#160;</a></span>setProjectionMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setProjectionMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_mat4_8h.html#aa543bb38f59d79a08113a6254b587322">fMat4</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the projection matrix. </p>
<p >This is the matrix that is used to project coordinate from 'view space' to normalized device coordinates (NDC).</p>
<p >Call this method to set a "custom" projection matrix. For the usual perspective and orthographic matrices, use instead <a class="el" href="classtgx_1_1_renderer3_d.html#af0ae032c0be73580be8e61c53ad42545" title="Set the projection matrix as a perspective matrix https://www.khronos.org/registry/OpenGL-Refpages/gl...">setFrustum()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a8437622c6b90f9429769504848d22456" title="Set the projection matrix as a perspective matrix https://www.khronos.org/registry/OpenGL-Refpages/gl...">setPerspective()</a>, <a class="el" href="classtgx_1_1_renderer3_d.html#a8ff9976b53c527e62c95be427620685f" title="Set the projection matrix as an orthographic matrix: https://www.khronos.org/registry/OpenGL-Refpages...">setOrtho()</a>.</p>
<p ><b>Note</b></p>
<ul>
<li>When using perspective projection, the projection matrix must store <code>-z</code> into the <code>w</code> component.</li>
<li>In view space, the camera is assumed to be centered at the origin, looking looking toward the negative Z axis with the Y axis pointing up (as in opengl).</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtgx_1_1_renderer3_d.html#a4bce4752b73a38862733b4f2bcb6f04f" title="Get a copy of the current projection matrix.">getProjectionMatrix()</a> </dd></dl>

</div>
</div>
<a id="a04191294450f9371c8c99e869075b40e" name="a04191294450f9371c8c99e869075b40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04191294450f9371c8c99e869075b40e">&#9670;&#160;</a></span>setShaders()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setShaders </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shaders</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the shaders to use for subsequent drawing operations. </p>
<p >A combination of the following flags.</p>
<p >NOTE: If a shader flag is set with SetShaders but is disabled in the template parameter LOADED_SHADER, then the drawing calls will silently fail (draw nothing) or, in the best case, sometime fall-back using another shader that is loaded.</p>
<ul>
<li><p class="startli">Choosing the shading algorithm: TGX_SHADER_FLAT or TGX_SHADER_GOURAUD (see <a href="https://en.wikipedia.org/wiki/Shading">https://en.wikipedia.org/wiki/Shading</a>)</p>
<p class="startli">TGX_SHADER_FLAT Use flat shading (i.e. uniform color on faces). This is the fastest drawing method but usually gives poor results when combined with texturing. Lighting transition between bright to dark aera may appear to 'flicker' when color_t = <a class="el" href="structtgx_1_1_r_g_b565.html" title="Color in R5/G6/B5 format.">RGB565</a> because of the limited number of colors/shades available.</p>
<p class="startli">-&gt; the color on the face is computed according to Phong's lightning model use the triangle face normals computed via crossproduct. <a href="https://en.wikipedia.org/wiki/Phong_reflection_model">https://en.wikipedia.org/wiki/Phong_reflection_model</a></p>
<p class="startli">TGX_SHADER_GOURAUD Give a color to each vertex and then use linear interpolation to shade each triangle according to its vertex colors. This results in smoother color transitions and works well with texturing but at a higher CPU cost.</p>
<p class="startli">-&gt; In order to use gouraud shading, a normal vector must be attributed to each vertex, which is then used to determine its color according to phong's lightning model.</p>
<p class="startli">-&gt; *** NORMAL VECTORS MUST ALWAYS BE NORMALIZED (UNIT LENGHT) ***</p>
<p class="startli">-&gt; When backface culling is enable, the normal vector must be that of the 'front face' (obviously). When backface culling is disabled, there is no more 'front' and 'back' face: by convention, the normal vector supplied must then be that corresponding to the counter- clockwise face.</p><ul>
<li><p class="startli">Enabling (perspective correct) texture mapping. <br  />
 Texture mapping is perspective correct and is performed in combination with TGX_SHADER_FLAT or TGX_SHADER_GOURAUD. The color of a pixel in the triangle is obtained by combining to texture color at that pixel with the lightning at the position (according to phong's lightning model again).</p>
<p class="startli">TGX_SHADER_TEXTURE enable texture mapping. -&gt; A texture must be stored in an Image&lt;color_t&gt; object</p>
<p class="startli">-&gt; wrap mode is set with <code><a class="el" href="classtgx_1_1_renderer3_d.html#af63f6218b3f5b451784eb32282102553" title="Set the wrap mode when using texturing.">setTextureWrappingMode()</a></code></p>
<p class="startli">-&gt; drawing quality is set with <code><a class="el" href="classtgx_1_1_renderer3_d.html#a78f24c4f139eccc4b9a695ca681970cc" title="Set the texturing quality.">setTextureQuality()</a></code></p>
<p class="startli">-&gt; NOTE: Large textures stored in flash memory may be VERY slow to access when the texture is not read linearly which will happens for some (bad) triangle orientations and then cache becomes useless... This problem can be somewhat mitigated by:</p>
<p class="startli">(a) splitting large textured triangles into smaller ones: then each triangle only accesses a small part of the texture. This helps a lot wich cache optimizatrion [this is why models with thousands of faces may display faster that a simple textured cube in some cases :-)].</p>
<p class="startli">(b) moving the image into RAM if possible. Even moving the texture from FLASH to EXTMEM (if available) will usually give a great speed boost ! </p>
</li>
</ul>
</li>
</ul>

</div>
</div>
<a id="a78f24c4f139eccc4b9a695ca681970cc" name="a78f24c4f139eccc4b9a695ca681970cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f24c4f139eccc4b9a695ca681970cc">&#9670;&#160;</a></span>setTextureQuality()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setTextureQuality </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quality</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the texturing quality. </p>
<p >One of</p>
<p >TGX_SHADER_TEXTURE_NEAREST Use nearest neighbour point sampling when texturing. (fastest method).</p>
<p >TGX_SHADER_TEXTURE_BILINEAR Use bilinear interpolation when texturing (slower but higher quality). </p>

</div>
</div>
<a id="af63f6218b3f5b451784eb32282102553" name="af63f6218b3f5b451784eb32282102553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63f6218b3f5b451784eb32282102553">&#9670;&#160;</a></span>setTextureWrappingMode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setTextureWrappingMode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wrap_mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the wrap mode when using texturing. </p>
<p >One of:</p>
<p >TGX_SHADER_TEXTURE_WRAP_POW2 Wrap around (repeat) the texture. This is the fastest mode. </p><pre class="fragment">                              !!! WARNING : WHEN USING THIS FLAG, THE TEXTURE MUST HAVE DIMENSIONS 
                                  THAT ARE POWER OF 2 ALONG EACH AXIS !!!
</pre><p >TGX_SHADER_TEXTURE_CLAMP Clamp to the edge. Slower than above but the texture can be any size. </p>

</div>
</div>
<a id="a6cad095ff0d7eefbdb93ac04b6a3efff" name="a6cad095ff0d7eefbdb93ac04b6a3efff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cad095ff0d7eefbdb93ac04b6a3efff">&#9670;&#160;</a></span>setViewMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setViewMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_mat4_8h.html#aa543bb38f59d79a08113a6254b587322">fMat4</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the view tranformation matrix. </p>
<p >This matrix is used to transform vertices from world coordinates to view coordinates (ie from the point of view of the camera)</p>
<p >Thus, changing this matrix changes the position of the camera in the world space.</p>
<p >IMPORTANT: In view space (i.e. after transformation), the camera is assumed to be centered at the origin, looking looking toward the negative Z axis with the Y axis pointing up (as in opengl). </p>

</div>
</div>
<a id="a6f1030e0892d613c3406811755bda599" name="a6f1030e0892d613c3406811755bda599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f1030e0892d613c3406811755bda599">&#9670;&#160;</a></span>setViewportSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setViewportSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_vec2_8h.html#a37eab41759a1a4093ac2fbde648b4c0f">iVec2</a> &amp;&#160;</td>
          <td class="paramname"><em>viewport_dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the size of the viewport. </p>
<p >Same as <code><a class="el" href="classtgx_1_1_renderer3_d.html#a7222e72a480ce99a8eb3d3df2dfec0aa" title="Set the size of the viewport.">setViewportSize(int lx, int ly)</a></code>. </p>

</div>
</div>
<a id="a7222e72a480ce99a8eb3d3df2dfec0aa" name="a7222e72a480ce99a8eb3d3df2dfec0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7222e72a480ce99a8eb3d3df2dfec0aa">&#9670;&#160;</a></span>setViewportSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setViewportSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the size of the viewport. </p>
<p >The normalized coordinates in <code>[-1,1]x[-1,1]</code> are mapped to <code>[0,lx-1]x[0,ly-1]</code> just before rasterization.</p>
<p >It is possible to use a viewport larger than the image drawn onto by using an offset for the image inside the viewport in order to perform 'tile rendering'. see <code><a class="el" href="classtgx_1_1_renderer3_d.html#afc1eaf179bc6573ab508ab3a7e38dab9" title="Set the offset of the image relative to the viewport.">setOffset()</a></code>.</p>
<p >the maximum viewport size depends on <code>TGX_RASTERIZE_SUBPIXEL_BITS</code> which specifies the sub-pixel precision value used by the 3D rasterizer:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">subpixel bits   </th><th class="markdownTableHeadNone">max viewport size LX*LY    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone">2048 x 2048    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">6   </td><td class="markdownTableBodyNone">4096 x 4096    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone">8192 x 8192    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">16384 x 16384   </td></tr>
</table>

</div>
</div>
<a id="a516e700a5470f52cbd9a82dd59f8c968" name="a516e700a5470f52cbd9a82dd59f8c968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516e700a5470f52cbd9a82dd59f8c968">&#9670;&#160;</a></span>setZbuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::setZbuffer </td>
          <td>(</td>
          <td class="paramtype">ZBUFFER_t *&#160;</td>
          <td class="paramname"><em>zbuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the zbuffer. </p>
<p >Warning: the zbuffer must be large enough to be used with the image that is being drawn onto. This means that we must have length &gt;= image.width()*image.height().</p>
<ul>
<li>Setting a valid zbuffer automatically turns on z-buffering.</li>
<li>Removing the z-buffer (by setting it to nullptr) turns off z-buffering. </li>
</ul>

</div>
</div>
<a id="a76c4ce4af7e3c7da2e3a1a7d1d0d4f01" name="a76c4ce4af7e3c7da2e3a1a7d1d0d4f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c4ce4af7e3c7da2e3a1a7d1d0d4f01">&#9670;&#160;</a></span>worldToImage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_vec2_8h.html#a37eab41759a1a4093ac2fbde648b4c0f">iVec2</a> <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::worldToImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a>&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert from world coord. </p>
<p >to the corresponding image pixel.</p>
<ul>
<li>P : point given in the word coordinate system.</li>
</ul>
<p >Return the position of the associated pixel on the image.</p>
<p >Note: - the position returned may be outside of the image !</p><ul>
<li>return (0,0) if no image inserted. </li>
</ul>

</div>
</div>
<a id="a3eac08822d93c5fa419d7cc566aa636d" name="a3eac08822d93c5fa419d7cc566aa636d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eac08822d93c5fa419d7cc566aa636d">&#9670;&#160;</a></span>worldToViewPort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename color_t , int LOADED_SHADERS = TGX_SHADER_MASK_ALL, typename ZBUFFER_t  = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_vec4_8h.html#a66dc844afdc508c1137c733caa63695b">fVec4</a> <a class="el" href="classtgx_1_1_renderer3_d.html">tgx::Renderer3D</a>&lt; color_t, LOADED_SHADERS, ZBUFFER_t &gt;::worldToViewPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_vec3_8h.html#a99f7adbde40341ee92cc8f2bac0b6af2">fVec3</a>&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert from world coord. </p>
<p >to the standard viewport coord.</p>
<ul>
<li>P : point given in the word coordinate system. <br  />
</li>
</ul>
<p >Return the projection of P on the standard viewport [-1,1]^2 according to the current position of the camera.</p>
<p >Note: - the model matrix is not taken into account here.</p><ul>
<li>the .w value can be used for depth testing. </li>
</ul>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="_renderer3_d_8h_source.html">Renderer3D.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>tgx</b></li><li class="navelem"><a class="el" href="classtgx_1_1_renderer3_d.html">Renderer3D</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
